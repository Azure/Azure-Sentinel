// Name: Azure storage key enumeration
//
// Description: Listing of storage keys is an interesting operation in Azure which might expose additional 
// secrets and PII to callers as well as granting access to VMs. While there are many benign operations of this
// type, it would be interesting to see if the account performing this activity or the source IP address from 
// which it is being done is anomalous. 
// The query below generates known clusters of ip address per caller, notice that users which only had single
// operations do not appear in this list as we cannot learn from it their normal activity (only based on a single
// event). The activities for listing storage account keys is correlated with this learned 
// clusters of expected activities and activity which is not expected is returned.
//
// Data source: AzureActivity
//
// Techniques: #Lateral Movement
//
AzureActivity
| where OperationName == "List Storage Account Keys"
| where ActivityStatus == "Succeeded" 
| join kind= inner (
    AzureActivity
    | where OperationName == "List Storage Account Keys"
    | where ActivityStatus == "Succeeded" 
    | project ExpectedIpAddress=CallerIpAddress, Caller 
    | evaluate autocluster()
) on Caller 
| where CallerIpAddress !=  ExpectedIpAddress
| project OperationName, ResourceId, Caller, CallerIpAddress
| distinct *
// Name: Common deployed resources
//
// Description: this query looks for common deployed resources (resource name and resource groups) and can be used
// in combination with other signals that show suspicious deployment to evaluate if the resource is one
// that is commonly being deployed/created or unique.
//
// Data source: AzureActivity
//
// Techniques: #Execution
//
AzureActivity
| where OperationName == "Create or Update Virtual Machine" or OperationName == "Create Deployment" 
| where ActivityStatus == "Succeeded" 
| project Resource, ResourceGroup 
| evaluate basket()
// Name: Creation of an anomalous number of resources
//
// Description: looks for anomalous number of resources creation or deployment activities in azure activity log.
// It is best to run this query on a look back period which is at least 7 days.
//
// Data source: AzureActivity
//
// Techniques: #Execution
//
AzureActivity
| where OperationName == "Create or Update Virtual Machine" or OperationName == "Create Deployment" 
| where ActivityStatus == "Succeeded" 
| make-series dcount(ResourceId)  default=0 on EventSubmissionTimestamp in range(ago(7d), now(), 1d) by Caller
| render timechart 
// Name: Granting permissions to account
//
// Description: shows the most prevalent users who grant access to others on azure resources and for each account 
// their common source ip address. If an operation is not from this IP address it may be worthy of investigation.
//
// Data source: AzureActivity
//
// Techniques: #Persistence, #Lateral Movement
//
AzureActivity
| where OperationName == "Create role assignment"
| where ActivityStatus == "Succeeded" 
| project EventSubmissionTimestamp, Caller, CallerIpAddress, SubscriptionId, ResourceId 
| project Caller, CallerIpAddress
| evaluate basket()
// Name: Traffic to known bad IPs
//
// Description:
// Microsoft tracks a significant number of threat actors/malware/botnets etc so as to protect its products and services.
// The query shows traffic to known malicious IPs associated with various spam campaigns, botnets , virus etc. 
// Examining traffic to these known malicious IPs is a potential avenue to discover attacks in your environment.
// Data feeds used -  W3CIISLog , DnsEvents , WindowsFirewall, WireData , CommonSecurityLog
//  Union has been done  using Fuzzy logic so that even if at least one data feed from above is available the query would execute
//
// Data Source: CommonSecurityLog,DnsEvents,W3CIISLog,WireData,WindowsFirewall
//
// Techniques: #C2, #Exfiltration
//
union 
(union isfuzzy=true
(W3CIISLog | extend Country=RemoteIPCountry, Latitude=RemoteIPLatitude, Longitude=RemoteIPLongitude),
(DnsEvents | extend Country= RemoteIPCountry, Latitude = RemoteIPLatitude, Longitude = RemoteIPLongitude | extend Computer = ClientIP),
(WireData | where Direction != 'Outbound' | extend Country=RemoteIPCountry, Latitude=RemoteIPLatitude, Longitude=RemoteIPLongitude),
(WindowsFirewall | where CommunicationDirection != 'SEND' | extend Country=MaliciousIPCountry, Latitude=MaliciousIPLatitude, Longitude=MaliciousIPLongitude),
(CommonSecurityLog | where CommunicationDirection != 'Outbound' | extend Country=MaliciousIPCountry, Latitude=MaliciousIPLatitude, Longitude=MaliciousIPLongitude, Confidence=ThreatDescription, Description=ThreatDescription)
| where isnotempty(MaliciousIP) and isnotempty(Country) and isnotempty(Latitude) and isnotempty(Longitude) | extend TrafficDirection="InboundOrUnknown"),
(union isfuzzy=true
(WireData | where Direction == 'Outbound' | extend Country=RemoteIPCountry, Latitude=RemoteIPLatitude, Longitude=RemoteIPLongitude),
(WindowsFirewall | where CommunicationDirection == 'SEND' | extend Country=MaliciousIPCountry, Latitude=MaliciousIPLatitude, Longitude=MaliciousIPLongitude),
(CommonSecurityLog | where CommunicationDirection == 'Outbound' | extend Country=MaliciousIPCountry, Latitude=MaliciousIPLatitude, Longitude=MaliciousIPLongitude, Confidence=ThreatDescription, Description=ThreatDescription)
| where isnotempty(MaliciousIP) and isnotempty(Country) and isnotempty(Latitude) and isnotempty(Longitude) | extend TrafficDirection="Outbound")
| project TimeGenerated, IndicatorThreatType, Confidence, Severity, Computer, LocalIP, LocalPortNumber, RemoteIP, RemotePortNumber, Direction, ProcessName, SentBytes, ReceivedBytes, TenantId, ReportReferenceLink, Type 
// Uncomment this to get more detailed breakdown -- but may massively increase number of rows in result set
//, MaliciousIP , Malcious_Domain = Name
| parse kind = regex ReportReferenceLink with "tags=((webbot\\+)|(controller\\+)|(bot\\+))?" Family:string '&languageCode' *
| summarize makeset(Computer) by IndicatorThreatType, Severity, Family, Type, ReportReferenceLink 
// Uncomment this to get more detailed breakdown -- but may massively increase number of rows in result set
//, MaliciousIP , Malicious_Domain 
// Name: Summary of users creating new user accounts
//
// Description: creating new user accounts is a privileged activity that may be abused by attackers to provide persistent access.
// Reviewing which user accounts have been created, and by whom, can help detect attacker attempts to provide themselves with backdoor access to data.
//
// Data source: OfficeActivity
//
// Techniques: #Persistence
//
OfficeActivity
| where Operation == "Add user."
| project addedBy=UserId, newUser=OfficeObjectId 
| summarize newUserCount=dcount(newUser) by addedBy
| render barchart
// Name: Accounts and User Agents associated with multiple IPs in Office Azure Active Directory authentications.
//
// Description: summary of users/user agents associated with authentications from multiple IPs within a short timeframe.
// This query computes and joins two tables to highlight IPs associated with multiple authentications:
// 1- UserAgents seen in authentications from multiple IPs within short timeframe
// 2- User Ids seen authenticated from multiple IPs
// The time window join looks for instances of a small elpased time between logons.
//
// Data source: OfficeActivity
//
// Techniques: #InitialAccess
//
let timeRange=ago(7d);
let officeAuthentications = 
OfficeActivity
| where TimeGenerated >= timeRange
| where RecordType in ("AzureActiveDirectoryAccountLogon", "AzureActiveDirectoryStsLogon") 
| extend UserAgent = extractjson("$[0].Value", ExtendedProperties, typeof(string))
| where Operation == "UserLoggedIn";
// We will perform a time window join to identify useragents seen from multiple IPs within a 1-day period
let lookupWindow = 1d;
let lookupBin = lookupWindow / 2.0; // lookup bin = equal to 1/2 of the lookup window
officeAuthentications
| project-rename Start=TimeGenerated
| extend TimeKey = bin(Start, lookupBin) 
| join kind = inner (
  officeAuthentications | project-rename End=TimeGenerated
                        // TimeKey on the right side of the join - emulates this authentication appearing several times
                        | extend TimeKey = range(bin(End - lookupWindow, lookupBin),
                         bin(End, lookupBin),
                        lookupBin)
                        // translate TimeKey arrange range to a column
                        | mvexpand TimeKey to typeof(datetime)
) on UserAgent, TimeKey 
| project timeSpan = End - Start, UserId, ClientIP , UserAgent , Start, End
| summarize dcount(ClientIP) by  UserAgent
| where dcount_ClientIP >1
| join kind=inner (
   // User IDs associated with multiple different client IPs within a 1-day period:
   // Because of the join we can increase the timeframe for  which we consider accounts with multiple source IPs
   officeAuthentications
   | summarize minTime=min(TimeGenerated), maxTime=max(TimeGenerated), dcount(ClientIP) by UserId, UserAgent
   | project UserId, dcount_ClientIP , timeSpan = maxTime-minTime, UserAgent 
   | where dcount_ClientIP >1 and timeSpan <= 1d
   | project UserId, distinctIPCount=dcount_ClientIP, timeSpan, UserAgent) on UserAgent
| project UserAgent, UserId, distinctIPCount  
// Name: sharepoint downloads from previously unseen IP address.
//
// Description: Shows volume of documents uploaded to or downloaded from Sharepoint by new IP addresses. 
// In stable environments such connections by new IPs may be unauthorized, especially if associated with spikes in volume which could be associated with large-scale document exfiltration.
//
// Data source: OfficeActivity
//
// Techniques: #Exfiltration
//
let historicalActivity=
OfficeActivity
| where  RecordType == "SharePointFileOperation"
| where Operation in ("FileDownloaded", "FileUploaded")
| where TimeGenerated between(ago(30d)..ago(7d))
| summarize historicalCount=count() by ClientIP;
let recentActivity = OfficeActivity
| where  RecordType == "SharePointFileOperation"
| where Operation in ("FileDownloaded", "FileUploaded")
| where TimeGenerated > ago(1d) 
| summarize recentCount=count() by ClientIP;
recentActivity | join kind= leftanti (
   historicalActivity 
) on ClientIP; 
// Name: sharepoint downloads from devices associated with previously unseen user agents.
//
// Description: tracking via user agent is one way to differentiate between types of connecting device. 
// In homogeneous enterprise environments the user agent associated with an attacker device may stand out as unusual. 
// In stable environments such connections by new IPs may be unauthorized, especially if associated with spikes in volume
// which could be associated with large-scale document exfiltration.
//
// Data source: OfficeActivity
//
// Techniques: #Exfiltration
//
let historicalActivity=
OfficeActivity
| where  RecordType == "SharePointFileOperation"
| where Operation in ("FileDownloaded", "FileUploaded")
| where TimeGenerated between(ago(30d)..ago(7d))
| summarize historicalCount=count() by UserAgent;
let recentActivity = OfficeActivity
| where  RecordType == "SharePointFileOperation"
| where Operation in ("FileDownloaded", "FileUploaded")
| where TimeGenerated > ago(1d) 
| summarize recentCount=count() by UserAgent;
recentActivity | join kind= leftouter (
   historicalActivity 
) on UserAgent; 
// Name: New user agents associated with a clientIP for sharepoint file uploads/downloads
//
// Description: New user agents associated with a clientIP for sharepoint file uploads/downloads. 
//
// Data source: OfficeActivity
//
// Techniques: #Exfiltration
//
let historicalUA=
OfficeActivity
| where  RecordType == "SharePointFileOperation"
| where Operation in ("FileDownloaded", "FileUploaded")
| where TimeGenerated between(ago(30d)..ago(7d))
| summarize by ClientIP, UserAgent;
let recentUA = OfficeActivity
| where  RecordType == "SharePointFileOperation"
| where Operation in ("FileDownloaded", "FileUploaded")
| where TimeGenerated > ago(1d) 
| summarize by ClientIP, UserAgent;
recentUA | join kind=leftanti (
   historicalUA 
) on ClientIP, UserAgent; 
// Name: cscript script daily summary breakdown
//
// Description:  breakdown of scripts running in the environment
//
// Data source: SecurityEvent
//
// Techniques: #Execution
//
let ProcessCreationEvents=() {
let processEvents=SecurityEvent
| where EventID==4688
| project EventTime=TimeGenerated, ComputerName=Computer,AccountName=SubjectUserName, AccountDomain=SubjectDomainName,
FileName=tostring(split(NewProcessName, '\\')[-1]),
ProcessCommandLine = CommandLine, 
InitiatingProcessFileName=ParentProcessName,InitiatingProcessCommandLine="",InitiatingProcessParentFileName="";
processEvents;
};
// Daily summary of cscript activity – extracting script name and parameters from commandline:
ProcessCreationEvents | where FileName =~ "cscript.exe"
| project removeSwitches = replace(@"/+[a-zA-Z0-9:]+", "", ProcessCommandLine) // remove commandline switches
| project CommandLine = trim(@"[a-zA-Z0-9\\:""]*cscript(.exe)?("")?(\s)+", removeSwitches) // remove the leading cscript.exe process name 
// extract the script name: 
| project ScriptName= iff(CommandLine startswith @"""", 
                       extract(@"([:\\a-zA-Z_\-\s0-9\.()]+)(""?)", 0, CommandLine), // handle case where script name is enclosed in " characters
                       extract(@"([:\\a-zA-Z_\-0-9\.()]+)(""?)", 0, CommandLine))   // handle case where script name is not enclosed in quotes                    
                       , CommandLine 
| project ScriptName=trim(@"""", ScriptName) , ScriptNameLength=strlen(ScriptName), CommandLine 
// extract remainder of commandline as script parameters: 
| project ScriptName, ScriptParams = iff(ScriptNameLength < strlen(CommandLine), substring(CommandLine, ScriptNameLength +1), "")
| summarize by ScriptName, ScriptParams // Name: Enumeration of users and groups 

// Description: finds attempts to list users or groups using the built-in Windows 'net' tool 

// Data source: SecurityEvent

// Techniques: #Discovery

let ProcessCreationEvents=() {
let processEvents=SecurityEvent
| where EventID==4688
| project  TimeGenerated, ComputerName=Computer,AccountName=SubjectUserName,        AccountDomain=SubjectDomainName,
FileName=tostring(split(NewProcessName, '\\')[-1]),
ProcessCommandLine = CommandLine, 
FolderPath = "",
InitiatingProcessFileName=ParentProcessName,InitiatingProcessCommandLine="",InitiatingProcessParentFileName="";
processEvents};
ProcessCreationEvents
| where FileName == 'net.exe' and AccountName != "" and ProcessCommandLine !contains '\\'  and ProcessCommandLine !contains '/add' 
| where (ProcessCommandLine contains ' user ' or ProcessCommandLine contains ' group ') and (ProcessCommandLine endswith ' /do' or ProcessCommandLine endswith ' /domain') 
| extend Target = extract("(?i)[user|group] (\"*[a-zA-Z0-9-_ ]+\"*)", 1, ProcessCommandLine) | filter Target  != '' 
| project AccountName, Target, ProcessCommandLine, ComputerName, TimeGenerated  
| sort by AccountName, Target// Name: masquerading files.

// Description: Malware writers often use windows system process names for their malicious process names to make them blend 
// in with other legitimate commands that the Windows system executes.
// An analyst can create a simple query looking for a process named svchost.exe. 
// It is recommended to filter out well-known security identifiers (SIDs) that are used to launch the legitimate svchost.exe process. 
// The query also filters out the legitimate locations from which svchost.exe is launched.
//
// Data source: SecurityEvent
//
// Techniques: #Execution, #Defense Evasion
//
SecurityEvent
| where ProcessName contains "svchost.exe"
| where SubjectUserSid != "S-1-5-18"
| where SubjectUserSid != "S-1-5-19"
| where SubjectUserSid != "S-1-5-20"
| where NewProcessName !contains ":\\Windows\\System32"
| where NewProcessName !contains ":\\Windows\\Syswow64"

  
// Name: Summary of users created using uncommon & undocumented commandline switches
//
// Description: Summarizes uses of uncommon & undocumented commandline switches to create persistence
// User accounts may be created to achieve persistence on a machine.
// Read more here: https://attack.mitre.org/wiki/Technique/T1136
// Query for users being created using "net user" command
// "net user" commands are noisy, so needs to be joined with another signal -
// e.g. in this example we look for some undocumented variations (e.g. /ad instead of /add)
//
// Data source: SecurityEvent
//
// Techniques: #Persistence
//
SecurityEvent
| where EventID==4688
| project  TimeGenerated, ComputerName=Computer,AccountName=SubjectUserName, 
    AccountDomain=SubjectDomainName, FileName=tostring(split(NewProcessName, '\\')[-1]), 
    ProcessCommandLine = CommandLine, 
    FolderPath = "", InitiatingProcessFileName=ParentProcessName,
    InitiatingProcessCommandLine="",InitiatingProcessParentFileName=""
| where FileName in~ ("net.exe", "net1.exe")
| parse kind=regex flags=iU ProcessCommandLine with * "user " CreatedUser " " * "/ad"
| where not(FileName =~ "net1.exe" and InitiatingProcessFileName =~ "net.exe" and replace("net", "net1", InitiatingProcessCommandLine) =~ ProcessCommandLine)
| extend CreatedOnLocalMachine=(ProcessCommandLine !contains "/do")
| where ProcessCommandLine contains "/add" or (CreatedOnLocalMachine == 0 and ProcessCommandLine !contains "/domain")
| summarize MachineCount=dcount(ComputerName) by CreatedUser, CreatedOnLocalMachine, InitiatingProcessFileName, FileName, ProcessCommandLine, InitiatingProcessCommandLine
// Name: powershell downloads
//
// Description: Finds PowerShell execution events that could involve a download
//
// Data source: SecurityEvent
//
// Techniques: #Initial Access, #Execution, #Persistence
//
let ProcessCreationEvents=() {
let processEvents=SecurityEvent
| where EventID==4688
| project  TimeGenerated, ComputerName=Computer,AccountName=SubjectUserName,        AccountDomain=SubjectDomainName,
  FileName=tostring(split(NewProcessName, '\\')[-1]),
ProcessCommandLine = CommandLine, 
InitiatingProcessFileName=ParentProcessName,InitiatingProcessCommandLine="",InitiatingProcessParentFileName="";
processEvents};
ProcessCreationEvents
| where FileName in~ ("powershell.exe", "powershell_ise.exe")
| where ProcessCommandLine has "Net.WebClient"
   or ProcessCommandLine has "DownloadFile"
   or ProcessCommandLine has "Invoke-WebRequest"
   or ProcessCommandLine has "Invoke-Shellcode"
   or ProcessCommandLine contains "http:"
| project TimeGenerated, ComputerName, InitiatingProcessFileName, FileName, ProcessCommandLine
| top 100 by TimeGenerated// Name: new powershell scripts encoded on the commandline
//
// Description: Identify and decode new encoded powershell scripts this week versus previous fortnight
//
// Data source: SecurityEvent
//
// Techniques: #Initial Access, #Execution, #Persistence
//
let ProcessCreationEvents=() {
let processEvents=SecurityEvent
| where EventID==4688
| project  TimeGenerated, ComputerName=Computer,AccountName=SubjectUserName,AccountDomain=SubjectDomainName,
  FileName=tostring(split(NewProcessName, '\\')[-1]),
ProcessCommandLine = CommandLine, 
InitiatingProcessFileName=ParentProcessName,InitiatingProcessCommandLine="",InitiatingProcessParentFileName="";
processEvents};
let encodedPSScripts = 
ProcessCreationEvents | where TimeGenerated >= ago(21d)
| where FileName =~ "powershell.exe"
| where ProcessCommandLine contains "-encodedCommand";
encodedPSScripts
| where TimeGenerated > ago(7d)
| summarize count() by ProcessCommandLine
| parse ProcessCommandLine with * "-EncodedCommand " encodedCommand
| project decodedCommand=base64_decodestring(substring(encodedCommand, 0, 
 strlen(encodedCommand) - (strlen(encodedCommand) %8))), encodedCommand 
| join kind=anti (encodedPSScripts
  | where TimeGenerated between(ago(21d)..ago(7d))
  | summarize count() by ProcessCommandLine
  | parse ProcessCommandLine with * "-EncodedCommand " encodedCommand
  | project decodedCommand=base64_decodestring(substring(encodedCommand, 0, 
   strlen(encodedCommand) - (strlen(encodedCommand) %8))), encodedCommand 
) on encodedCommand, decodedCommand 
// Name: Windows - Process + Commandline Rare for Host
// Description: This hunting version will help you lookup your interesting process and see on what hosts it is rare, including command line.  
// Less than 1% of the average for 30 days and less than a count of 100 on a given host or less than a 14 count on a given host from the last 7 days
//
// Entity: Process
// Input: ProcessName
// Output: Hosts
//
// QueryPeriod: -7d, change as needed
//
// Data Source: Syslog
//
// Techniques: #Execution, #Persistence, #Discovery, #Lateral Movement, #Collection
//
let GetHostWithRareProcess = (suspiciousEventTime:datetime, v_Process:string){
let v_StartTime = suspiciousEventTime-7d;
let v_EndTime = suspiciousEventTime-1m;
SecurityEvent
| where EventID == 4688
| where TimeGenerated between (v_StartTime .. v_EndTime)
| where NewProcessName has v_Process
| where isnotempty(CommandLine) and NewProcessName !endswith ":\\windows\\system32\\conhost.exe" and tolower(CommandLine) != tolower(NewProcessName) and tolower(CommandLine) != tolower(strcat('\"',NewProcessName,'\"'," "))
| summarize count() by Computer, NewProcessName, CommandLine
| join kind= inner (
    SecurityEvent
    | where EventID == 4688
    // get avg from last 30 days
    | where TimeGenerated >= ago(30d)
	| where NewProcessName has v_Process
    | where isnotempty(CommandLine) and NewProcessName !endswith ":\\windows\\system32\\conhost.exe" and tolower(CommandLine) != tolower(NewProcessName) and tolower(CommandLine) != tolower(strcat('\"',NewProcessName,'\"'," "))
    | summarize count() by Computer, NewProcessName, CommandLine
    | summarize avg(count_) by NewProcessName, CommandLine
    ) on NewProcessName, CommandLine
// attempt to control for noise, but not miss low prevalence count with low average count
| where count_ < 7 or (count_ <= avg_count_*0.01 and count_ < 100)
| join kind= inner (
    SecurityEvent
    | where EventID == 4688
    | where TimeGenerated between (v_StartTime .. v_EndTime)
	| where NewProcessName has v_Process
    | where isnotempty(CommandLine) and NewProcessName !endswith ":\\windows\\system32\\conhost.exe" and tolower(CommandLine) != tolower(NewProcessName) and tolower(CommandLine) != tolower(strcat('\"',NewProcessName,'\"'," "))
    | summarize min(TimeGenerated), max(TimeGenerated) by Computer, NewProcessName, CommandLine
) on Computer, NewProcessName, CommandLine
| project min_TimeGenerated, max_TimeGenerated, EventCount = count_, AvgEventCountAllSystems = avg_count_, Computer, NewProcessName, CommandLine 
| top 10 by EventCount asc nulls last 
| project min_TimeGenerated, max_TimeGenerated, Computer, NewProcessName, CommandLine, EventCount, AvgEventCountAllSystems 
};
// change datetime value and <processname> value below
GetHostWithRareProcess(datetime('2019-01-31T10:36:07Z'), "<processname>")// Name: uncommon processes - bottom 5%
//
// Description: Identify and decode new encoded powershell scripts this week versus previous fortnight
//
// Description:
// Shows the rarest processes seen running for the first time. (Performs best over longer time ranges - eg 3+ days rather than 24 hours!)
// These new processes could be benign new programs installed on hosts; 
// However, especially in normally stable environments, these new processes could provide an indication of an unauthorized/malicious binary that has been installed and run. 
// Reviewing the wider context of the logon sessions in which these binaries ran can provide a good starting point for identifying possible attacks.
//
// Data source: SecurityEvent
//
// Techniques: #Initial Access, #Execution, #Persistence, #Privilege Escalation, #Credential Access, #Discovery, #Lateral Movement, #Collection, #Exfiltration, #Command and Control
//
let ProcessCreationEvents=() {
    let processEvents=SecurityEvent
    | where EventID==4688
    // filter out common randomly named files related to MSI installers and browsers
    | where not(NewProcessName matches regex @"Temp\\[0-9]{1}\\TRA[0-9A-Fa-f]{3}\.tmp")
    | where not(NewProcessName matches regex @"Temp\\[0-9]{1}\\TRA[0-9A-Fa-f]{4}\.tmp")
    | where not(NewProcessName matches regex @"Installer\\MSI[0-9A-Fa-f]{3}\.tmp")
    | where not(NewProcessName matches regex @"Installer\\MSI[0-9A-Fa-f]{4}\.tmp")
    | project TimeGenerated, 
      ComputerName=Computer,
      AccountName=SubjectUserName, 
      AccountDomain=SubjectDomainName,
      FileName=tostring(split(NewProcessName, '\\')[-1]),
      ProcessCommandLine = CommandLine, 
      InitiatingProcessFileName=ParentProcessName,
      InitiatingProcessCommandLine="",
      InitiatingProcessParentFileName="";
    processEvents;
    };
    let normalizedProcesses = ProcessCreationEvents 
       | project TimeGenerated, FileName = replace("[0-9A-Fa-f]{8}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{12}", "<guid>", FileName) // normalize guids
       | project TimeGenerated, FileName=replace(@'\d', 'n', FileName); // normalize digits away
    let freqs = normalizedProcesses
    | summarize frequency=count() by FileName
    | join kind= leftouter (
       normalizedProcesses
       | summarize Since=min(TimeGenerated), LastSeen=max(TimeGenerated) by FileName
    ) on FileName;
    freqs 
    | where frequency <= toscalar( freqs | serialize | project frequency | summarize percentiles(frequency, 5))
    | order by frequency asc
    | project FileName, frequency, Since, LastSeen 
    // restrict results to unusual processes seen in last day 
    | where LastSeen >= ago(1d)// Name: anomalous sign-in location by user account and authenticating application
//
// Description: This query over Azure Active Directory sign-in considers all user sign-ins for each Azure Active 
// Directory application and picks out the most anomalous change in location profile for a user within an 
// individual application. The intent is to hunt for user account compromise, possibly via a specific application
// vector.
//
// Data source: SigninLogs
//
// Techniques: #InitialAccess
//
let timeRange=ago(30d);
SigninLogs 
// Forces Log Analytics to recognize that the query should be run over full time range
| where TimeGenerated >= timeRange
| extend  locationString= strcat(tostring(LocationDetails["countryOrRegion"]), "/", tostring(LocationDetails["state"]), "/", tostring(LocationDetails["city"]), ";") 
| project TimeGenerated, AppDisplayName , UserPrincipalName, locationString 
// Create time series 
| make-series dLocationCount = dcount(locationString) on TimeGenerated in range(timeRange,now(), 1d) 
by UserPrincipalName, AppDisplayName 
// Compute best fit line for each entry 
| extend (RSquare,Slope,Variance,RVariance,Interception,LineFit)=series_fit_line(dLocationCount) 
// Chart the 3 most interesting lines  
// A 0-value slope corresponds to an account being completely stable over time for a given Azure Active Directory application
| top 3 by Slope desc  
| render timechart// Name: anomalous sign-in location by user account and authenticating application - with sign-in details
//
// Description: This query over Azure Active Directory sign-in considers all user sign-ins for each Azure Active 
// Directory application and picks out the most anomalous change in location profile for a user within an 
// individual application. The intent is to hunt for user account compromise, possibly via a specific application
// vector.
// This variation of the query joins the results back onto the original sign-in data to allow review of the 
// location set with each identified user in tabular form.
//
// Data source: SigninLogs
//
// Techniques: #InitialAccess
//
let timeRange=ago(30d);
SigninLogs 
// Forces Log Analytics to recognize that the query should be run over full time range
| where TimeGenerated >= timeRange
| extend  locationString= strcat(tostring(LocationDetails["countryOrRegion"]), "/", tostring(LocationDetails["state"]), "/", tostring(LocationDetails["city"]), ";") 
| project TimeGenerated, AppDisplayName , UserPrincipalName, locationString 
// Create time series 
| make-series dLocationCount = dcount(locationString) on TimeGenerated in range(timeRange,now(), 1d) 
by UserPrincipalName, AppDisplayName 
// Compute best fit line for each entry 
| extend (RSquare,Slope,Variance,RVariance,Interception,LineFit)=series_fit_line(dLocationCount) 
// Chart the 3 most interesting lines  
// A 0-value slope corresponds to an account being completely stable over time for a given Azure Active Directory application
| top 3 by Slope desc  
// Extract the set of locations for each top user:
| join kind=inner (SigninLogs
| where TimeGenerated >= timeRange
| extend  locationString= strcat(tostring(LocationDetails["countryOrRegion"]), "/", tostring(LocationDetails["state"]), "/", tostring(LocationDetails["city"]), ";")// , tostring(LocationDetails["geoCoordinates"]))
| summarize locationList = makeset(locationString), threeDayWindowLocationCount=dcount(locationString) by AppDisplayName , UserPrincipalName, timerange=bin(TimeGenerated, 3d)) on AppDisplayName, UserPrincipalName
| order by UserPrincipalName, timerange asc
| project timerange, AppDisplayName , UserPrincipalName, threeDayWindowLocationCount, locationList 
 | order by AppDisplayName, UserPrincipalName, timerange asc// Name: Anomalous Azure Active Directory apps based on authentication location
//
// Description: This query over Azure AD sign-in activity highlights Azure AD apps with 
// an unusually high ratio of distinct geolocations versus total number of authentications
//
// Data source: SigninLogs
//
// Techniques: #InitialAccess
//
let timeRange=ago(14d);
let azureSignIns = 
SigninLogs
| where TimeGenerated >= timeRange
| where SourceSystem == "Azure AD"
| where OperationName == "Sign-in activity"
| project TimeGenerated, OperationName, AppDisplayName , Identity, UserId, UserPrincipalName, Location, LocationDetails , ClientAppUsed , DeviceDetail, ConditionalAccessPolicies;
azureSignIns
| extend locationString= strcat(tostring(LocationDetails["countryOrRegion"]), "/", tostring(LocationDetails["state"]), "/", tostring(LocationDetails["city"]), ";" , tostring(LocationDetails["geoCoordinates"]))
| summarize rawSigninCount=count(), countByAccount=dcount(UserId), locationCount=dcount(locationString) by AppDisplayName
| where rawSigninCount < 1000                     // tail - pick a threshold to rule out the very-high volume Azure AD apps
| where locationCount>countByAccount             // more locations than accounts
| where 1.0*rawSigninCount / locationCount > 0.8 // almost as many / more locations than sign-ins!
| order by rawSigninCount  desc
| join kind = leftouter (
   azureSignIns 
) on AppDisplayName 
| project AppDisplayName, TimeGenerated , Identity, rawSigninCount, countByAccount , locationCount,  locationString= strcat(tostring(LocationDetails["countryOrRegion"]), "/", tostring(LocationDetails["state"]), "/", tostring(LocationDetails["city"]), ";" , tostring(LocationDetails["geoCoordinates"]))
| order by AppDisplayName, TimeGenerated desc
// Name: Azure Active Directory signins from new locations.
//
// Description: New Azure Active Directory signin locations today versus historical Azure Active Directory signin data
// In the case of password spraying or brute force attacks one might see authentication attempts for many accounts from a new location.
//
// Data source: SigninLogs
//
// Techniques: #InitialAccess
//
SigninLogs
| where TimeGenerated >= ago(1d)
| summarize perIdentityAuthCount=count() by Identity,  locationString= strcat(tostring(LocationDetails["countryOrRegion"]), "/", tostring(LocationDetails["state"]), "/", tostring(LocationDetails["city"]), ";" , tostring(LocationDetails["geoCoordinates"]))
| summarize distinctAccountCount = count(), identityList=makeset(Identity)  by locationString
| extend identityList = iff(distinctAccountCount<10, identityList, "multiple (>10)")
| join kind= anti (
    SigninLogs
    | where TimeGenerated < ago(1d)
    | project   locationString= strcat(tostring(LocationDetails["countryOrRegion"]), "/", tostring(LocationDetails["state"]), "/", 
        tostring(LocationDetails["city"]), ";" , tostring(LocationDetails["geoCoordinates"]))
    | summarize priorCount = count() by locationString) on locationString
| where distinctAccountCount > 1 // select threshold above which #new accounts from a new location is deemed suspicious
// Could extend this query to show previous signin locations for the users in result set.

// Name: Azure Active Directory sign-in burst from multiple locations
//
// Description: This query over Azure Active Directory sign-in activity highlights accounts associated
// with multiple authentications from different geographical locations in a short space of time.
//
// Data source: SigninLogs
//
// Techniques: #InitialAccess
//
let timeRange=ago(10d);
let signIns = SigninLogs
| where TimeGenerated >= timeRange
| extend locationString= strcat(tostring(LocationDetails["countryOrRegion"]), "/", tostring(LocationDetails["state"]), "/", tostring(LocationDetails["city"]))  // , ";" , tostring(LocationDetails["geoCoordinates"]))
| where locationString != "//" 
// filter out signins associated with top 100 signin locations 
| join kind=anti (SigninLogs
   | extend locationString= strcat(tostring(LocationDetails["countryOrRegion"]), "/", tostring(LocationDetails["state"]), "/",
    tostring(LocationDetails["city"]))  // , ";" , tostring(LocationDetails["geoCoordinates"]))
    | where locationString != "//"
    | summarize count() by locationString
    | order by count_ desc
    | take 100) on locationString ; // TODO - make this threshold percentage-based
// We will perform a time window join to identify signins from multiple locations within a 10-minute period
let lookupWindow = 10m;
let lookupBin = lookupWindow / 2.0; // lookup bin = equal to 1/2 of the lookup window
signIns 
| project-rename Start=TimeGenerated 
| extend TimeKey = bin(Start, lookupBin)
| join kind = inner (
    signIns | project-rename End=TimeGenerated, EndLocationString=locationString 
    // TimeKey on the right side of the join - emulates this authentication appearing several times
    | extend TimeKey = range(bin(End - lookupWindow, lookupBin),
    bin(End, lookupBin),
    lookupBin)
    | mvexpand TimeKey to typeof(datetime) // translate TimeKey arrange range to a column
) on Identity, TimeKey
| where End > Start
| project timeSpan = End - Start, Identity, locationString, EndLocationString,tostring(Start),  tostring(End)
| where locationString != EndLocationString
| summarize by timeSpan, Identity, locationString, EndLocationString, Start, End
| order by Identity
// Name: Failed attempt to access Azure Portal
//
// Description: Access attempts to Azure Portal from an unauthorized user.  Either invalid password or the user account does not exist.
//
// Data source: SigninLogs
//
// Techniques: #InitialAccess
let timeRange=ago(7d);
SigninLogs
| where TimeGenerated >= timeRange
| extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser
| extend StatusCode = tostring(Status.errorCode), StatusDetails = tostring(Status.additionalDetails)
| extend State = tostring(LocationDetails.state), City = tostring(LocationDetails.city)
| where  AppDisplayName contains "Azure Portal"
// 50126 - Invalid username or password, or invalid on-premises username or password.
// 50020? - The user doesn't exist in the tenant.
| where ResultType in ( "50126" , "50020")
| summarize makelist(TimeGenerated), makeset(IPAddress), makeset(OS), makeset(Browser), makeset(City), count() by UserDisplayName, UserPrincipalName, AppDisplayName, ResultType, ResultDescription, StatusCode, StatusDetails, Location, State
| project UserDisplayName, UserPrincipalName, AppDisplayName, AttemptCount = count_, list_TimeGenerated, DistinctIPCount = arraylength(set_IPAddress), set_IPAddress, ResultType, ResultDescription, StatusCode, StatusDetails, set_OS, set_Browser, Location, State, set_City
| sort by AttemptCount