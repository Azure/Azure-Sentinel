Parser:
  Title: Network Session ASIM filtering parser for Azure Firewall logs
  Version: '0.2.0'
  LastUpdated: Dec 3, 2025
Product:
  Name: Azure Firewall
Normalization:
  Schema: NetworkSession
  Version: '0.2.6'
References:
  - Title: ASIM Network Session Schema
    Link: https://aka.ms/ASimNetworkSessionDoc
  - Title: ASIM
    Link: https://aka.ms/AboutASIM
Description: |
  This ASIM parser supports filtering and normalizing Azure Firewall logs to the ASIM Network Session normalized schema. This parser is partially based on a work by [Koos Goossens](https://github.com/TheCloudScout).
ParserName: vimNetworkSessionAzureFirewall
EquivalentBuiltInParser: _Im_NetworkSession_AzureFirewall
ParserParams:
  - Name: starttime
    Type: datetime
    Default: datetime(null)
  - Name: endtime
    Type: datetime
    Default: datetime(null)
  - Name: srcipaddr_has_any_prefix
    Type: dynamic
    Default: dynamic([])
  - Name: dstipaddr_has_any_prefix
    Type: dynamic
    Default: dynamic([])
  - Name: ipaddr_has_any_prefix
    Type: dynamic
    Default: dynamic([])
  - Name: dstportnumber
    Type: int
    Default: int(null)
  - Name: hostname_has_any
    Type: dynamic
    Default: dynamic([])
  - Name: dvcaction
    Type: dynamic
    Default: dynamic([])
  - Name: eventresult
    Type: string
    Default: '*'
  - Name: disabled
    Type: bool
    Default: false
ParserQuery: |
  let parser = (
        starttime:datetime=datetime(null), 
        endtime:datetime=datetime(null), 
        srcipaddr_has_any_prefix:dynamic=dynamic([]), 
        dstipaddr_has_any_prefix:dynamic=dynamic([]), 
        ipaddr_has_any_prefix:dynamic=dynamic([]),
        dstportnumber:int=int(null), 
        hostname_has_any:dynamic=dynamic([]), 
        dvcaction:dynamic=dynamic([]), 
        eventresult:string='*', 
        disabled:bool=false)
  {
      let ip_any=set_union(srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix);
      let src_or_any=set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
      let dst_or_any=set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix);
      // AZFWIdpsSignature provides a numerical severity value
      let NumericalEventSeverityLookup = datatable (Severity:int, NumericalEventSeverity:string)
      [
        1, "High",
        2, "Medium",
        3, "Low",
        4, "Informational"
      ];
      let DvcActionLookup = datatable (UpperAction:string, DvcAction:string, EventResult: string, ActionEventSeverity: string)
      [
        "ALLOW", "Allow", "Success", "Informational",
        "",      "Allow", "Success", "Informational", // AZFWNatRule does not have Action, always indicates success
        "DENY",  "Deny",  "Failure", "Low",
        "DROP",  "Drop",  "Failure", "Low"
      ];
      let legacy_AzureFirewallNetworkRuleLogs = 
          AzureDiagnostics
          | where (isnull(starttime) or TimeGenerated >= starttime) 
            and (isnull(endtime)   or TimeGenerated <= endtime) 
            and not(disabled)
          | where Category == "AzureFirewallNetworkRule"
          | where isnotempty(msg_s)
          | project msg_s, OperationName, SubscriptionId, ResourceId, TimeGenerated, Type, _ResourceId;
      let prefilter = (T: (msg_s:string, TimeGenerated:datetime, OperationName:string)) {
        T | where  
         (array_length(hostname_has_any) == 0)
         and (isnull(dstportnumber) or msg_s has (tostring(dstportnumber)))
         and (array_length(ip_any)==0 
            or has_any_ipv4_prefix(msg_s,ip_any)
          ) 
      };
      let legacy_AzureFirewallSessionLogs = 
          legacy_AzureFirewallNetworkRuleLogs
          | where OperationName in ("AzureFirewallNetworkRuleLog","AzureFirewallThreatIntelLog")
          // -- pre-filter
          | where (array_length(dvcaction) == 0) or (msg_s has_any (dvcaction))
          | where (eventresult == "*") or ((eventresult == "Success") and (msg_s has "Allow")) or ((eventresult == "Failure") and (msg_s has "Deny"))
          | invoke prefilter()
          // -- end pre-filter
          | parse-where
              msg_s with           Protocol:string 
              " request from "     SrcIpAddr:string
              ":"                  SrcPortNumber:int
              " to "               DstIpAddr:string
              ":"                  DstPortNumber:int
              ". Action: "         DvcAction:string
              "."                  *
          | project-away msg_s
          | extend temp_isSrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any)
                 , temp_isDstMatch=has_any_ipv4_prefix(DstIpAddr,dst_or_any)
           | extend ASimMatchingIpAddr = case(
                array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-" 
                , (temp_isSrcMatch and temp_isDstMatch), "Both" // has to be checked before the individual 
                , temp_isSrcMatch, "SrcIpAddr"
                , temp_isDstMatch, "DstIpAddr"
                , "No match"
             )
          | project-away temp_*
          | where ASimMatchingIpAddr != "No match"
          | extend EventSeverity = case (
              OperationName  == "AzureFirewallThreatIntelLog", "Medium",
              DvcAction == "Deny", "Low",
              "Informational")
          | extend EventResult = iff(DvcAction == "Allow", "Success", "Failure")
          ;
      let legacy_AzureFirewallNATLogs = 
          legacy_AzureFirewallNetworkRuleLogs
          | where OperationName == "AzureFirewallNatRuleLog"
          // -- pre-filter
          | where (array_length(dvcaction) == 0) or ("Allow" in (dvcaction))
          | where eventresult in ("*", "Success")
          | invoke prefilter()
          // -- end pre-filter
          | parse-where
              msg_s with           Protocol:string 
              " request from "     SrcIpAddr:string
              ":"                  SrcPortNumber:int
              " to "               DstIpAddr:string
              ":"                  DstPortNumber:int
              " was DNAT'ed to "   DstNatIpAddr:string
              ":"                  DstNatPortNumber:int
          | project-away msg_s
          | extend temp_isSrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any)
                 , temp_isDstMatch=has_any_ipv4_prefix(DstIpAddr,dst_or_any)
           | extend ASimMatchingIpAddr = case(
                array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-" 
                , (temp_isSrcMatch and temp_isDstMatch), "Both" // has to be checked before the individual 
                , temp_isSrcMatch, "SrcIpAddr"
                , temp_isDstMatch, "DstIpAddr"
                , "No match"
             )
          | project-away temp_*
          | where ASimMatchingIpAddr != "No match"
          | extend EventSeverity = "Informational"
          | extend EventResult = "Success"
          | extend DvcAction = "Allow"
          ;
      let AZFWNetworkSessionLogs = 
            AZFWNetworkRule
            | union AZFWNatRule
            | union AZFWIdpsSignature
            | union AZFWThreatIntel
            | where not(disabled)
            // Pre-filter time
            | where (isnull(starttime) or TimeGenerated >= starttime)
                    and (isnull(endtime) or TimeGenerated <= endtime)
            // Pre-filter Action
            | extend UpperAction = toupper(Action)
            // IDPS Signature and ThreatIntel tables contain alerts, exclude these to avoid duplicate network session logs
            | where UpperAction != "ALERT"
            | lookup DvcActionLookup on UpperAction
            | where array_length(dvcaction) == 0 or DvcAction has_any (dvcaction)
            // Pre-filter IPs
            | extend temp_SrcMatch = has_any_ipv4_prefix(SourceIp, src_or_any), 
                     temp_DstMatch = has_any_ipv4_prefix(DestinationIp, dst_or_any)
            | extend ASimMatchingIpAddr = case(
                array_length(src_or_any) == 0 and array_length(dst_or_any) == 0 ,"-",
                temp_SrcMatch and temp_DstMatch, "Both",
                temp_SrcMatch, "SrcIpAddr",
                temp_DstMatch, "DstIpAddr",
                "No match"
            )
            | where ASimMatchingIpAddr != "No match"
            // Pre-filter by Hostname
            | extend
                temp_SrcHostMatch = SourceIp has_any(hostname_has_any),
                temp_DstHostMatch = DestinationIp has_any(hostname_has_any)
            | extend ASimMatchingHostname = case(
                array_length(hostname_has_any) == 0, "-",
                temp_SrcHostMatch and temp_DstHostMatch, "Both",
                temp_SrcHostMatch, "SrcDomain",
                temp_DstHostMatch, "DstDomain",
                "No match"
            )
            | where ASimMatchingHostname != "No match"
            // Pre-filter Event result
            | where eventresult == "*" or eventresult == EventResult
            // Determine Event Severity
            | lookup NumericalEventSeverityLookup on Severity
            | extend EventSeverity = iff(Type=="AZFWThreatIntel", "Medium", coalesce(NumericalEventSeverity, ActionEventSeverity))
            | project-rename
                EventOriginalUid = _ItemId,
                EventOriginalResultDetails = ActionReason,
                SrcIpAddr = SourceIp,
                SrcPortNumber = SourcePort,
                DstIpAddr = DestinationIp,
                DstPortNumber = DestinationPort,
                DstFQDN = Fqdn,
                DvcOriginalAction = Action,
                ThreatId = SignatureId,
                ThreatCategory = Category,
                EventReportUrl = TargetUrl,
                NetworkRuleName = Rule,
                DstNatIpAddr = TranslatedIp,
                DstNatPortNumber = TranslatedPort
            | extend
                ThreatName = coalesce(Description, ThreatDescription),
                AdditionalFields = bag_pack(
                    "Policy", Policy,
                    "RuleCollection", RuleCollection, 
                    "RuleCollectionGroup", RuleCollectionGroup,
                    "SourceSystem", SourceSystem,
                    "IsTlsInspected", IsTlsInspected
                )
            | project-away
                ThreatDescription;
      union legacy_AzureFirewallSessionLogs, legacy_AzureFirewallNATLogs, AZFWNetworkSessionLogs
      | where 
          (isnull(dstportnumber) or DstPortNumber==dstportnumber)
      // Extract Network Information
      | extend temp_Protocol = toupper(Protocol)
      | extend NetworkProtocol = iff(temp_Protocol startswith "ICMP", "ICMP", temp_Protocol)
      | extend NetworkIcmpCode = iff(NetworkProtocol == "ICMP", toint(extract("(?i)TYPE=(\\d+)", 1, temp_Protocol)), int(null))
      | extend NetworkIcmpType = iff(isnotnull(NetworkIcmpCode), _ASIM_LookupICMPType(NetworkIcmpCode), "")
      | extend
          EventVendor="Microsoft",
          EventProduct="Azure Firewall",
          EventType="NetworkSession",
          EventCount=toint(1),
          EventSchemaVersion="0.2.6",
          EventSchema="NetworkSession",
          DvcIdType = "AzureResourceId"
      | extend 
          DvcId = coalesce(ResourceId, _ResourceId),
          DvcSubscriptionId = coalesce(SubscriptionId, _SubscriptionId)
      // -- Aliases
      | extend
          IpAddr = SrcIpAddr,
          Src = SrcIpAddr,
          SrcHostname = SrcIpAddr,
          Dst = DstIpAddr,
          DstHostname = DstIpAddr,
          Dvc = DvcId,
          Hostname = DstIpAddr,
          EventStartTime = TimeGenerated,
          EventEndTime = TimeGenerated
      | project-keep
          ASim*,
          Src*,
          Dst*,
          Event*,
          Dvc*,
          IpAddr,
          Hostname,
          Network*,
          Threat*,
          Type,
          AdditionalFields,
          _BilledSize,
          _IsBillable,
          _ResourceId,
          _SubscriptionId,
          TenantId,
          TimeGenerated
  };
  parser  (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, disabled)