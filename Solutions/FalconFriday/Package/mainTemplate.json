{
  "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
  "contentVersion": "1.0.0.0",
  "metadata": {
    "author": "Nikhil Tripathi - v-ntripathi@microsoft.com",
    "comments": "Solution template for FalconFriday"
  },
  "parameters": {
    "location": {
      "type": "string",
      "minLength": 1,
      "defaultValue": "[resourceGroup().location]",
      "metadata": {
        "description": "Not used, but needed to pass arm-ttk test `Location-Should-Not-Be-Hardcoded`.  We instead use the `workspace-location` which is derived from the LA workspace"
      }
    },
    "workspace-location": {
      "type": "string",
      "minLength": 1,
      "defaultValue": "[parameters('location')]",
      "metadata": {
        "description": "Region to deploy solution resources"
      }
    },
    "workspace": {
      "defaultValue": "",
      "type": "string",
      "metadata": {
        "description": "Workspace name for Log Analytics where Sentinel is setup"
      }
    },
    "analytic1-id": {
      "type": "string",
      "defaultValue": "[newGuid()]",
      "minLength": 1,
      "metadata": {
        "description": "Unique id for the scheduled alert rule"
      }
    },
    "analytic2-id": {
      "type": "string",
      "defaultValue": "[newGuid()]",
      "minLength": 1,
      "metadata": {
        "description": "Unique id for the scheduled alert rule"
      }
    },
    "analytic3-id": {
      "type": "string",
      "defaultValue": "[newGuid()]",
      "minLength": 1,
      "metadata": {
        "description": "Unique id for the scheduled alert rule"
      }
    },
    "analytic4-id": {
      "type": "string",
      "defaultValue": "[newGuid()]",
      "minLength": 1,
      "metadata": {
        "description": "Unique id for the scheduled alert rule"
      }
    },
    "analytic5-id": {
      "type": "string",
      "defaultValue": "[newGuid()]",
      "minLength": 1,
      "metadata": {
        "description": "Unique id for the scheduled alert rule"
      }
    },
    "analytic6-id": {
      "type": "string",
      "defaultValue": "[newGuid()]",
      "minLength": 1,
      "metadata": {
        "description": "Unique id for the scheduled alert rule"
      }
    },
    "analytic7-id": {
      "type": "string",
      "defaultValue": "[newGuid()]",
      "minLength": 1,
      "metadata": {
        "description": "Unique id for the scheduled alert rule"
      }
    },
    "analytic8-id": {
      "type": "string",
      "defaultValue": "[newGuid()]",
      "minLength": 1,
      "metadata": {
        "description": "Unique id for the scheduled alert rule"
      }
    },
    "analytic9-id": {
      "type": "string",
      "defaultValue": "[newGuid()]",
      "minLength": 1,
      "metadata": {
        "description": "Unique id for the scheduled alert rule"
      }
    },
    "analytic10-id": {
      "type": "string",
      "defaultValue": "[newGuid()]",
      "minLength": 1,
      "metadata": {
        "description": "Unique id for the scheduled alert rule"
      }
    },
    "analytic11-id": {
      "type": "string",
      "defaultValue": "[newGuid()]",
      "minLength": 1,
      "metadata": {
        "description": "Unique id for the scheduled alert rule"
      }
    },
    "analytic12-id": {
      "type": "string",
      "defaultValue": "[newGuid()]",
      "minLength": 1,
      "metadata": {
        "description": "Unique id for the scheduled alert rule"
      }
    },
    "analytic13-id": {
      "type": "string",
      "defaultValue": "[newGuid()]",
      "minLength": 1,
      "metadata": {
        "description": "Unique id for the scheduled alert rule"
      }
    },
    "analytic14-id": {
      "type": "string",
      "defaultValue": "[newGuid()]",
      "minLength": 1,
      "metadata": {
        "description": "Unique id for the scheduled alert rule"
      }
    },
    "analytic15-id": {
      "type": "string",
      "defaultValue": "[newGuid()]",
      "minLength": 1,
      "metadata": {
        "description": "Unique id for the scheduled alert rule"
      }
    },
    "analytic16-id": {
      "type": "string",
      "defaultValue": "[newGuid()]",
      "minLength": 1,
      "metadata": {
        "description": "Unique id for the scheduled alert rule"
      }
    },
    "analytic17-id": {
      "type": "string",
      "defaultValue": "[newGuid()]",
      "minLength": 1,
      "metadata": {
        "description": "Unique id for the scheduled alert rule"
      }
    },
    "analytic18-id": {
      "type": "string",
      "defaultValue": "[newGuid()]",
      "minLength": 1,
      "metadata": {
        "description": "Unique id for the scheduled alert rule"
      }
    },
    "analytic19-id": {
      "type": "string",
      "defaultValue": "[newGuid()]",
      "minLength": 1,
      "metadata": {
        "description": "Unique id for the scheduled alert rule"
      }
    },
    "analytic20-id": {
      "type": "string",
      "defaultValue": "[newGuid()]",
      "minLength": 1,
      "metadata": {
        "description": "Unique id for the scheduled alert rule"
      }
    }
  },
  "variables": {
    "AzureADRareUserAgentAppSignin_AnalyticalRules": "AzureADRareUserAgentAppSignin_AnalyticalRules",
    "_AzureADRareUserAgentAppSignin_AnalyticalRules": "[variables('AzureADRareUserAgentAppSignin_AnalyticalRules')]",
    "AzureADUserAgentOSmissmatch_AnalyticalRules": "AzureADUserAgentOSmissmatch_AnalyticalRules",
    "_AzureADUserAgentOSmissmatch_AnalyticalRules": "[variables('AzureADUserAgentOSmissmatch_AnalyticalRules')]",
    "COMHijacking_AnalyticalRules": "COMHijacking_AnalyticalRules",
    "_COMHijacking_AnalyticalRules": "[variables('COMHijacking_AnalyticalRules')]",
    "CertutilIngressToolTransfer_AnalyticalRules": "CertutilIngressToolTransfer_AnalyticalRules",
    "_CertutilIngressToolTransfer_AnalyticalRules": "[variables('CertutilIngressToolTransfer_AnalyticalRules')]",
    "CreateProcessWithToken_AnalyticalRules": "CreateProcessWithToken_AnalyticalRules",
    "_CreateProcessWithToken_AnalyticalRules": "[variables('CreateProcessWithToken_AnalyticalRules')]",
    "DCOMLateralMovement_AnalyticalRules": "DCOMLateralMovement_AnalyticalRules",
    "_DCOMLateralMovement_AnalyticalRules": "[variables('DCOMLateralMovement_AnalyticalRules')]",
    "DLLSideLoading_AnalyticalRules": "DLLSideLoading_AnalyticalRules",
    "_DLLSideLoading_AnalyticalRules": "[variables('DLLSideLoading_AnalyticalRules')]",
    "DisableOrModifyWindowsDefender_AnalyticalRules": "DisableOrModifyWindowsDefender_AnalyticalRules",
    "_DisableOrModifyWindowsDefender_AnalyticalRules": "[variables('DisableOrModifyWindowsDefender_AnalyticalRules')]",
    "DotNetToJScript_AnalyticalRules": "DotNetToJScript_AnalyticalRules",
    "_DotNetToJScript_AnalyticalRules": "[variables('DotNetToJScript_AnalyticalRules')]",
    "ExpiredAccessCredentials_AnalyticalRules": "ExpiredAccessCredentials_AnalyticalRules",
    "_ExpiredAccessCredentials_AnalyticalRules": "[variables('ExpiredAccessCredentials_AnalyticalRules')]",
    "MatchLegitimateNameOrLocation_AnalyticalRules": "MatchLegitimateNameOrLocation_AnalyticalRules",
    "_MatchLegitimateNameOrLocation_AnalyticalRules": "[variables('MatchLegitimateNameOrLocation_AnalyticalRules')]",
    "OfficeASRFromBrowser_AnalyticalRules": "OfficeASRFromBrowser_AnalyticalRules",
    "_OfficeASRFromBrowser_AnalyticalRules": "[variables('OfficeASRFromBrowser_AnalyticalRules')]",
    "OfficeProcessInjection_AnalyticalRules": "OfficeProcessInjection_AnalyticalRules",
    "_OfficeProcessInjection_AnalyticalRules": "[variables('OfficeProcessInjection_AnalyticalRules')]",
    "PasswordSprayingWithMDE_AnalyticalRules": "PasswordSprayingWithMDE_AnalyticalRules",
    "_PasswordSprayingWithMDE_AnalyticalRules": "[variables('PasswordSprayingWithMDE_AnalyticalRules')]",
    "RecognizingBeaconingTraffic_AnalyticalRules": "RecognizingBeaconingTraffic_AnalyticalRules",
    "_RecognizingBeaconingTraffic_AnalyticalRules": "[variables('RecognizingBeaconingTraffic_AnalyticalRules')]",
    "RemoteDesktopProtocol_AnalyticalRules": "RemoteDesktopProtocol_AnalyticalRules",
    "_RemoteDesktopProtocol_AnalyticalRules": "[variables('RemoteDesktopProtocol_AnalyticalRules')]",
    "RenameSystemUtilities_AnalyticalRules": "RenameSystemUtilities_AnalyticalRules",
    "_RenameSystemUtilities_AnalyticalRules": "[variables('RenameSystemUtilities_AnalyticalRules')]",
    "SMBWindowsAdminShares_AnalyticalRules": "SMBWindowsAdminShares_AnalyticalRules",
    "_SMBWindowsAdminShares_AnalyticalRules": "[variables('SMBWindowsAdminShares_AnalyticalRules')]",
    "SuspiciousParentProcessRelationship_AnalyticalRules": "SuspiciousParentProcessRelationship_AnalyticalRules",
    "_SuspiciousParentProcessRelationship_AnalyticalRules": "[variables('SuspiciousParentProcessRelationship_AnalyticalRules')]",
    "TrustedDeveloperUtilitiesProxyExecution_AnalyticalRules": "TrustedDeveloperUtilitiesProxyExecution_AnalyticalRules",
    "_TrustedDeveloperUtilitiesProxyExecution_AnalyticalRules": "[variables('TrustedDeveloperUtilitiesProxyExecution_AnalyticalRules')]",
    "sourceId": "falconforcebv1623147592118.falconfriday_content",
    "_sourceId": "[variables('sourceId')]"
  },
  "resources": [
    {
      "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
      "name": "[concat(parameters('workspace'),'/Microsoft.SecurityInsights/',parameters('analytic1-id'))]",
      "apiVersion": "2020-01-01",
      "kind": "Scheduled",
      "location": "[parameters('workspace-location')]",
      "properties": {
        "description": "This query establishes a baseline of the type of UserAgent (i.e. browser, office application, etc) that is typically used for a particular application by looking back for a number of days. \nIt then searches the current day for any deviations from this pattern, i.e. types of UserAgents not seen before in combination with this application.",
        "displayName": "Azure AD Rare UserAgent App Sign-in",
        "enabled": false,
        "query": "let minimumAppThreshold = 100;\nlet timeframe = 1d;\nlet lookback_timeframe= 7d;\nlet ExtractBrowserTypeFromUA=(ua:string) {\n    // Note: these are in a specific order since, for example, Edge contains \"Chrome/\" and \"Edge/\" strings.\n    case(\n        ua has \"Edge/\", dynamic({\"AgentType\": \"Browser\", \"AgentName\": \"Edge\"}),\n        ua has \"Edg/\", dynamic({\"AgentType\": \"Browser\", \"AgentName\": \"Edge\"}),\n        ua has \"Trident/\", dynamic({\"AgentType\": \"Browser\", \"AgentName\": \"Internet Explorer\"}),\n        ua has \"Chrome/\" and ua has \"Safari/\", dynamic({\"AgentType\": \"Browser\", \"AgentName\": \"Chrome\"}),\n        ua has \"Gecko/\" and ua has \"Firefox/\", dynamic({\"AgentType\": \"Browser\", \"AgentName\": \"Firefox\"}),\n        not(ua has \"Mobile/\") and ua has \"Safari/\" and ua has \"Version/\", dynamic({\"AgentType\": \"Browser\", \"AgentName\": \"Safari\"}),\n        ua startswith \"Dalvik/\" and ua has \"Android\", dynamic({\"AgentType\": \"Browser\", \"AgentName\": \"Android Browser\"}),\n        ua startswith \"MobileSafari//\", dynamic({\"AgentType\": \"Browser\", \"AgentName\": \"Mobile Safari\"}),\n        ua has \"Mobile/\" and ua has \"Safari/\" and ua has \"Version/\", dynamic({\"AgentType\": \"Browser\", \"AgentName\": \"Mobile Safari\"}),\n        ua has \"Mobile/\" and ua has \"FxiOS/\", dynamic({\"AgentType\": \"Browser\", \"AgentName\": \"IOS Firefox\"}),\n        ua has \"Mobile/\" and ua has \"CriOS/\", dynamic({\"AgentType\": \"Browser\", \"AgentName\": \"IOS Chrome\"}),\n        ua has \"Mobile/\" and ua has \"WebKit/\", dynamic({\"AgentType\": \"Browser\", \"AgentName\": \"Mobile Webkit\"}),\n        //\n        ua startswith \"Excel/\", dynamic({\"AgentType\": \"OfficeApp\", \"AgentName\": \"Excel\"}),\n        ua startswith \"Outlook/\", dynamic({\"AgentType\": \"OfficeApp\", \"AgentName\": \"Outlook\"}),\n        ua startswith \"OneDrive/\", dynamic({\"AgentType\": \"OfficeApp\", \"AgentName\": \"OneDrive\"}),\n        ua startswith \"OneNote/\", dynamic({\"AgentType\": \"OfficeApp\", \"AgentName\": \"OneNote\"}),\n        ua startswith \"Office/\", dynamic({\"AgentType\": \"OfficeApp\", \"AgentName\": \"Office\"}),\n        ua startswith \"PowerPoint/\", dynamic({\"AgentType\": \"OfficeApp\", \"AgentName\": \"PowerPoint\"}),\n        ua startswith \"PowerApps/\", dynamic({\"AgentType\": \"OfficeApp\", \"AgentName\": \"PowerApps\"}),\n        ua startswith \"SharePoint/\", dynamic({\"AgentType\": \"OfficeApp\", \"AgentName\": \"SharePoint\"}),\n        ua startswith \"Word/\", dynamic({\"AgentType\": \"OfficeApp\", \"AgentName\": \"Word\"}),\n        ua startswith \"Visio/\", dynamic({\"AgentType\": \"OfficeApp\", \"AgentName\": \"Visio\"}),\n        ua startswith \"Whiteboard/\", dynamic({\"AgentType\": \"OfficeApp\", \"AgentName\": \"Whiteboard\"}),\n        ua =~ \"Mozilla/5.0 (compatible; MSAL 1.0)\", dynamic({\"AgentType\": \"OfficeApp\", \"AgentName\": \"Office Telemetry\"}),\n        //\n        ua has \".NET CLR\", dynamic({\"AgentType\": \"Custom\", \"AgentName\": \"Dotnet\"}),\n        ua startswith \"Java/\", dynamic({\"AgentType\": \"Custom\", \"AgentName\": \"Java\"}),\n        ua startswith \"okhttp/\", dynamic({\"AgentType\": \"Custom\", \"AgentName\": \"okhttp\"}),\n        ua has \"Drupal/\", dynamic({\"AgentType\": \"Custom\", \"AgentName\": \"Drupal\"}),\n        ua has \"PHP/\", dynamic({\"AgentType\": \"Custom\", \"AgentName\": \"PHP\"}),\n        ua startswith \"curl/\", dynamic({\"AgentType\": \"Custom\", \"AgentName\": \"curl\"}),\n        ua has \"python-requests\", dynamic({\"AgentType\": \"Custom\", \"AgentName\": \"Python\"}),\n        pack(\"AgentType\",\"Other\",\"AgentName\", extract(@\"^([^/]*)/\",1,ua))\n    )\n};\n// Query to obtain 'simplified' user agents in a given timespan.\nlet QueryUserAgents = (start_time:timespan, end_time:timespan) {\n    union withsource=tbl_name AADNonInteractiveUserSignInLogs, SigninLogs\n    | where TimeGenerated >= ago(start_time)\n    | where TimeGenerated < ago(end_time)\n    | where ResultType == 0  // Only look at succesful logins\n    | extend ParsedUserAgent=ExtractBrowserTypeFromUA(UserAgent)\n    | extend UserAgentType=tostring(ParsedUserAgent.AgentType)\n    | extend UserAgentName=tostring(ParsedUserAgent.AgentName)\n    //| extend SimpleUserAgent=strcat(UserAgentType,\"_\",UserAgentName)\n    | extend SimpleUserAgent=UserAgentType\n    | where not(isempty(UserAgent))\n    | where not(isempty(AppId))\n};\n// Get baseline usage per application.\nlet BaselineUserAgents=materialize(\n    QueryUserAgents(lookback_timeframe+timeframe, timeframe)\n    | summarize RequestCount=count() by AppId, AppDisplayName, SimpleUserAgent\n);\nlet BaselineSummarizedAgents=(\n    BaselineUserAgents\n    | summarize BaselineUAs=make_set(SimpleUserAgent),BaselineRequestCount=sum(RequestCount) by AppId, AppDisplayName\n);\nQueryUserAgents(timeframe, 0d)\n| summarize count() by AppId, AppDisplayName, UserAgent, SimpleUserAgent\n| join kind=leftanti BaselineUserAgents on AppId, AppDisplayName, SimpleUserAgent\n| join BaselineSummarizedAgents on AppId, AppDisplayName\n| where BaselineRequestCount > minimumAppThreshold // Search only for actively used applications.\n// Get back full original requests.\n| join QueryUserAgents(timeframe, 0d) on AppId, UserAgent\n| project-away ParsedUserAgent, UserAgentName\n| project-reorder TimeGenerated, AppDisplayName, UserPrincipalName, UserAgent, BaselineUAs\n// Begin allow-list.\n// End allow-list.\n| summarize count() by UserPrincipalName, AppDisplayName, AppId, UserAgentType, SimpleUserAgent, UserAgent\n",
        "queryFrequency": "P1D",
        "queryPeriod": "P7D",
        "severity": "Medium",
        "suppressionDuration": "PT1H",
        "suppressionEnabled": false,
        "triggerOperator": "GreaterThan",
        "triggerThreshold": 0,
        "tactics": [
          "DefenseEvasion"
        ]
      }
    },
    {
      "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
      "name": "[concat(parameters('workspace'),'/Microsoft.SecurityInsights/',parameters('analytic2-id'))]",
      "apiVersion": "2020-01-01",
      "kind": "Scheduled",
      "location": "[parameters('workspace-location')]",
      "properties": {
        "description": "This query extracts the operating system from the UserAgent header and compares this to the DeviceDetail information present in Azure Active Directory.",
        "displayName": "Azure AD UserAgent OS Missmatch",
        "enabled": false,
        "query": "let timeframe = 1d;\nlet ExtractOSFromUA=(ua:string) {\n    case(\n        ua has \"Windows NT 6.0\", \"Windows Vista/Windows Server 2008\",\n        ua has \"Windows NT 6.1\", \"Windows 7/Windows Server 2008R2\",\n        ua has \"Windows NT 6.1\", \"Windows 7/Windows Server 2008\",\n        ua has \"Windows NT 6.2\", \"Windows 8/Windows Server 2012\",\n        ua has \"Windows NT 6.3\", \"Windows 8.1/Windows Server 2012R2\",\n        ua has \"Windows NT 10.0\", \"Windows 10\",\n        ua has \"Windows Phone\", \"WindowsPhone\",\n        ua has \"Android\", \"Android\",\n        ua has \"iPhone;\", \"IOS\",\n        ua has \"iPad;\", \"IOS\",\n        ua has \"Polycom/\", \"Polycom\",\n        ua has \"Darwin/\", \"MacOS\",\n        ua has \"Mac OS X\", \"MacOS\",\n        ua has \"macOS\", \"MacOS\",\n        ua has \"ubuntu\", \"Linux\",\n        ua has \"Linux\", \"Linux\",\n        ua has \"curl\", \"CLI\",\n        ua has \"python\", \"CLI\",\n        \"Unknown\"\n    )\n};\n// Query to obtain 'simplified' user agents in a given timespan.\nunion withsource=tbl_name AADNonInteractiveUserSignInLogs, SigninLogs\n| where TimeGenerated >= ago(timeframe)\n| extend UserAgentOS=tolower(ExtractOSFromUA(UserAgent))\n| where not(isempty(UserAgent))\n| where not(isempty(AppId))\n| where ResultType == 0\n| extend DeviceOS=tolower(DeviceDetail_dynamic.operatingSystem)\n| where not(isempty(DeviceOS))\n| where not(UserAgentOS == \"unknown\")\n// Look for matches both ways, since sometimes the browser OS is more specific and sometimes the DeviceOS is more specific.\n| where not(UserAgentOS contains DeviceOS) and not(DeviceOS contains UserAgentOS)\n| where not(DeviceOS == \"ios\" and UserAgentOS == \"macos\") // This can happen for 'request desktop site'\n| where not(DeviceOS == \"android\" and UserAgentOS == \"linux\") // Android and Linux sometimes confused\n| summarize count(), arg_min(TimeGenerated,*) by DeviceOS, UserAgentOS, UserPrincipalName\n// Begin allow-list.\n// End allow-list.\n",
        "queryFrequency": "P1D",
        "queryPeriod": "P1D",
        "severity": "Medium",
        "suppressionDuration": "PT1H",
        "suppressionEnabled": false,
        "triggerOperator": "GreaterThan",
        "triggerThreshold": 0,
        "tactics": [
          "DefenseEvasion"
        ]
      }
    },
    {
      "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
      "name": "[concat(parameters('workspace'),'/Microsoft.SecurityInsights/',parameters('analytic3-id'))]",
      "apiVersion": "2020-01-01",
      "kind": "Scheduled",
      "location": "[parameters('workspace-location')]",
      "properties": {
        "description": "This detection looks for the very specific value of \"Attribute\" in the \"ShellFolder\" CLSID of a COM object. This value (0xf090013d) seems to only link back to this specific persistence method. \nThe blog post linked here (https://www.ired.team/offensive-security/code-execution/forcing-iexplore.exe-to-load-a-malicious-dll-via-com-abuse) provides more background on the meaning of this value.",
        "displayName": "Component Object Model Hijacking - Vault7 trick",
        "enabled": false,
        "query": "DeviceRegistryEvents\n| where RegistryKey has \"ShellFolder\"  and ActionType =~ \"RegistryValueSet\" and RegistryValueName =~ \"Attributes\" \n// toint automatically converts base10 and base16 strings to int toint(\"0xFF\") == toint(\"255\") == int(0xFF) ==  int(255).\n// We are using >= to make sure that if someone adds an additional flag to this field, it doesn't bypass this hunt.\n// Removing any flag will bypass this hunt, but more research is needed to understand which of the flag values are relevant.\n| where toint(RegistryValueData) >= int(0xf090013d) \n//UPDATE: Flag details are here: https://medium.com/falconforce/introducing-falcon-friday-1f972d65ce1b?source=friends_link&sk=e48d9cb974e216cc4b9b61945a3b177d\n",
        "queryFrequency": "PT1H",
        "queryPeriod": "PT1H",
        "severity": "Medium",
        "suppressionDuration": "PT1H",
        "suppressionEnabled": false,
        "triggerOperator": "GreaterThan",
        "triggerThreshold": 0,
        "tactics": [
          "Persistence",
          "PrivilegeEscalation"
        ]
      }
    },
    {
      "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
      "name": "[concat(parameters('workspace'),'/Microsoft.SecurityInsights/',parameters('analytic4-id'))]",
      "apiVersion": "2020-01-01",
      "kind": "Scheduled",
      "location": "[parameters('workspace-location')]",
      "properties": {
        "description": "This detection addresses most of the known ways to utilize this binary for malicious/unintended purposes. \nIt attempts to accommodate for most detection evasion techniques, like commandline obfuscation and binary renaming.",
        "displayName": "Ingress Tool Transfer - Certutil",
        "enabled": false,
        "query": "// Set the time span for the query.\nlet Timeframe = 1h;\n// Set the HashTimeframe for the hash lookup; longer makes it more accurate, but obviously also more resource-intensive.\nlet HashTimeframe = 14d;\n// Get all known SHA1 hashes for certutil executions or renamed files formerly named certutil.\nlet CertUtilPESha1=materialize(DeviceProcessEvents | where Timestamp > ago(HashTimeframe)| where FileName has \"certutil\"  | where isnotempty(SHA1) | summarize sha1=make_set(SHA1));\nlet CertUtilFESha1=materialize(DeviceFileEvents | where Timestamp > ago(HashTimeframe)| where PreviousFileName contains \"certutil\" or FileName contains \"certutil\"  | where isnotempty(SHA1) | summarize sha1=make_set(SHA1));\nDeviceProcessEvents\n| where Timestamp >= ago(Timeframe)\n// Get all executions by processes with a SHA1 hash that is or was named certutil.\n| where SHA1 in (CertUtilPESha1) or SHA1 in (CertUtilFESha1) or FileName =~ \"certutil.exe\" or ProcessCommandLine has \"certutil\"\n// Create a new field called CleanProcessCommandLine which gets populated with the value of ProcessCommandLine as Windows parses it for execution, \n// removing any potential command line obfuscation. \n| extend CleanProcessCommandLine=parse_command_line(ProcessCommandLine, \"windows\")\n// Search for de-obfuscated commands used. \n// Urlcache is the documented attribute. However, url is also accepted.\n// Verifyctl is the documented attribute. However, verify is also accepted.\n| where CleanProcessCommandLine has_any (\"decode\", \"encode\", \"verify\",\"url\") \n| order by Timestamp\n",
        "queryFrequency": "PT1H",
        "queryPeriod": "P14D",
        "severity": "Low",
        "suppressionDuration": "PT1H",
        "suppressionEnabled": false,
        "triggerOperator": "GreaterThan",
        "triggerThreshold": 0,
        "tactics": [
          "CommandAndControl",
          "DefenseEvasion"
        ]
      }
    },
    {
      "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
      "name": "[concat(parameters('workspace'),'/Microsoft.SecurityInsights/',parameters('analytic5-id'))]",
      "apiVersion": "2020-01-01",
      "kind": "Scheduled",
      "location": "[parameters('workspace-location')]",
      "properties": {
        "description": "This query detects the use of the 'runas' command and checks whether the account used to elevate privileges isn't the user's own admin account. \nAdditionally, it will match this event to the logon events - to check whether it has been successful as well as augment the event with the new SID.",
        "displayName": "Access Token Manipulation - Create Process with Token",
        "enabled": false,
        "query": "let RunAsProcess=DeviceProcessEvents\n    | where FileName =~ \"runas.exe\" \n    // You can choose to filter out the local admin account. This is based on convention. Here, we assume that localadmin accounts\n    // end with _ladmin (RID 500 / LAPS).\n    | where not(AccountName has_any(\"_ladmin\"))\n    // De-obfuscate the commandline used. \n    | extend CleanProcessCommandLine=parse_command_line(tostring(ProcessCommandLine), \"windows\")\n    // Exclude a user running something on their system through their admin account.\n    | where CleanProcessCommandLine !contains strcat(AccountName, \"_adm\") // Replace this with your admin account naming convention.\n    // Exclude local admin account activities by, for instance, the servicedesk that uses the LAPS provisioned account. This is optional. \n    // Disable the line below if the number of false positives is acceptable. \n    | where not(CleanProcessCommandLine has_any (\":_ladmin\")) // Replace this with your local RID500/LAPS account.\n    // Extract the username for the elevation action.\n    | extend ElevatedAccountName=extract(\"user:([a-zA-Z0-9\\\\\\\\]+)\",1,tostring(CleanProcessCommandLine))\n    // Strip the domain suffix.\n    | extend CleanElevatedAccountName= trim(\"(.*\\\\\\\\)\",ElevatedAccountName);\nRunAsProcess\n| join kind=leftouter ( \n    DeviceLogonEvents\n    | project-rename CleanElevatedAccountName = AccountName\n    ) on CleanElevatedAccountName,DeviceId\n| project-rename ElevatedActionType=ActionType1,ElevatedAccountSid=AccountSid1\n| project TimeGenerated,DeviceId,DeviceName,FileName,FolderPath,ProcessCommandLine,SHA256,ProcessIntegrityLevel,AccountDomain,AccountName,AccountSid, LogonId, InitiatingProcessFileName,InitiatingProcessFolderPath,InitiatingProcessCommandLine,CleanProcessCommandLine,ElevatedAccountName,CleanElevatedAccountName,ElevatedActionType,LogonType,ElevatedAccountSid\n",
        "queryFrequency": "PT1H",
        "queryPeriod": "PT1H",
        "severity": "Medium",
        "suppressionDuration": "PT1H",
        "suppressionEnabled": false,
        "triggerOperator": "GreaterThan",
        "triggerThreshold": 0,
        "tactics": [
          "PrivilegeEscalation",
          "DefenseEvasion"
        ]
      }
    },
    {
      "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
      "name": "[concat(parameters('workspace'),'/Microsoft.SecurityInsights/',parameters('analytic6-id'))]",
      "apiVersion": "2020-01-01",
      "kind": "Scheduled",
      "location": "[parameters('workspace-location')]",
      "properties": {
        "description": "This detection looks for cases of close-time proximity between incoming network traffic on RPC/TCP, followed by the creation of a DCOM object, followed by the creation of a child process of the DCOM object. \nThe query first identifies incoming network traffic over RPC/TCP, followed by the creation of a DCOM object (process) within 2 seconds, followed by the creation of a child process of this DCOM object.",
        "displayName": "DCOM Lateral Movement",
        "enabled": false,
        "query": "let allowListedExecs = dynamic([\"TiWorker.exe\", \"dllhost.exe\", \"backgroundTaskHost.exe\", \"mobsync.exe\", \"WmiPrvSE.exe\", \"RuntimeBroker.exe\", \"smartscreen.exe\", \"SppExtComObj.Exe\", \"usocoreworker.exe\", \"browser_broker.exe\", \"ssoncom.exe\"]);\nlet rpcNetwEvents = materialize(DeviceNetworkEvents\n| where InitiatingProcessFileName =~ \"svchost.exe\" and InitiatingProcessCommandLine has \"rpcss\" and LocalPort == 135\n| where LocalIP !~ RemoteIP and ActionType != \"ListeningConnectionCreated\"\n| project TimestampNetwEvent=bin(Timestamp, 5s),TimestampNetwEventExact=Timestamp, DeviceId, DeviceName, RPCHostID=InitiatingProcessId, RPCHostFileName=InitiatingProcessFileName, LocalIP, RemoteIP);\nlet dcomProcEvents = materialize (DeviceProcessEvents\n| where InitiatingProcessFileName =~ \"svchost.exe\" and InitiatingProcessCommandLine has \"dcomlaunch\"\n| project TimestampProcEvent=bin(Timestamp, 5s),TimestampProcEventExact=Timestamp, DeviceId, DeviceName, DCOMHostPID=InitiatingProcessId, DCOMHostFileName=InitiatingProcessFileName, DCOMPID=ProcessId, DCOMFileName=FileName, DCOMCmdLine=ProcessCommandLine);\nlet lastBootTime = materialize(DeviceProcessEvents\n| where FileName =~ \"services.exe\"\n| summarize LastBootTime=max(Timestamp) by DeviceId);\nlet RemoteDcomProcs = materialize(rpcNetwEvents\n| join kind=inner dcomProcEvents on DeviceId \n| join kind=leftouter lastBootTime on DeviceId\n| where TimestampProcEvent > LastBootTime+5m // Ignore first 5 min after boot.\n// Avoiding < 2 since if the time between netw and proc creation is negative, they can't be related. Network event must come first. \n| where datetime_diff(\"second\", TimestampProcEventExact, TimestampNetwEventExact) between (0 .. 2) \n// Allow-listing some usual suspects which create lot of noise. This is dangerous though...huge gap for bypass. \n| where DCOMFileName  !in~ (allowListedExecs));\nRemoteDcomProcs\n| join kind=inner hint.strategy=broadcast (\n    DeviceProcessEvents \n    | where InitiatingProcessParentFileName =~ \"svchost.exe\" and InitiatingProcessFileName in ((RemoteDcomProcs | project DCOMFileName))) \non $left.DCOMHostPID == $right.InitiatingProcessParentId, DeviceId, $left.DCOMPID == $right.InitiatingProcessId\n| where InitiatingProcessParentFileName =~ \"svchost.exe\" and InitiatingProcessFileName =~ DCOMFileName \n// Allow-listing the magic of Defender.\n| where FileName !in~ (\"csc.exe\") \n| summarize make_set(ProcessCommandLine) by TimestampNetwEventExact, TimestampProcEventExact, DeviceId, DeviceName, InitiatingProcessId, LocalIP, RemoteIP, LastBootTime, DCOMCmdLine\n",
        "queryFrequency": "PT1H",
        "queryPeriod": "PT1H",
        "severity": "Medium",
        "suppressionDuration": "PT1H",
        "suppressionEnabled": false,
        "triggerOperator": "GreaterThan",
        "triggerThreshold": 0,
        "tactics": [
          "LateralMovement"
        ]
      }
    },
    {
      "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
      "name": "[concat(parameters('workspace'),'/Microsoft.SecurityInsights/',parameters('analytic7-id'))]",
      "apiVersion": "2020-01-01",
      "kind": "Scheduled",
      "location": "[parameters('workspace-location')]",
      "properties": {
        "description": "This detection tries to identify all DLLs loaded by \"high integrity\" processes and cross-checks the DLL paths against FileCreate/FileModify events of the same DLL by a medium integrity process. \nOf course, we need to do some magic to filter out false positives as much as possible. So any FileCreate/FileModify done by \"NT Authoriy\\System\" and the \"RID 500\" users aren't interesting. \nAlso, we only want to see the FileCreate/FileModify actions which are performed with a default or limited token elevation. If done with a full elevated token, the user is apparently admin already.",
        "displayName": "Hijack Execution Flow - DLL Side-Loading",
        "enabled": false,
        "query": "let imls = materialize(\n    DeviceImageLoadEvents\n    | where InitiatingProcessIntegrityLevel in (\"High\", \"System\") and FileName !endswith \".exe\"\n    | project FolderPath=tolower(FolderPath), InitiatingProcessFileName, InitiatingProcessIntegrityLevel, DeviceId, DeviceName\n    | distinct FolderPath, InitiatingProcessFileName, InitiatingProcessIntegrityLevel, DeviceId, DeviceName\n);\nimls \n| join (\n    DeviceFileEvents \n    | where FolderPath in~ ((imls | project FolderPath)) and ActionType in (\"FileCreated\", \"FileModified\") and \n    InitiatingProcessIntegrityLevel !in (\"High\", \"System\", \"\") and InitiatingProcessAccountSid != \"S-1-5-18\" and \n    InitiatingProcessTokenElevation in (\"TokenElevationTypeDefault\", \"TokenElevationTypeLimited\") and InitiatingProcessAccountSid !endswith \"-500\"\n    | extend FolderPath=tolower(FolderPath)\n) on FolderPath, DeviceId, DeviceName\n| project-away FolderPath1\n",
        "queryFrequency": "PT1H",
        "queryPeriod": "PT1H",
        "severity": "Medium",
        "suppressionDuration": "PT1H",
        "suppressionEnabled": false,
        "triggerOperator": "GreaterThan",
        "triggerThreshold": 0,
        "tactics": [
          "Persistence",
          "PrivilegeEscalation",
          "DefenseEvasion"
        ]
      }
    },
    {
      "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
      "name": "[concat(parameters('workspace'),'/Microsoft.SecurityInsights/',parameters('analytic8-id'))]",
      "apiVersion": "2020-01-01",
      "kind": "Scheduled",
      "location": "[parameters('workspace-location')]",
      "properties": {
        "description": "This detection watches the commandline logs for known commands that are used to disable the Defender AV. This is based on research performed by @olafhartong on a large sample of malware for varying purposes. \nNote that this detection is imperfect and is only meant to serve as basis for building a more resilient detection rule. \nMake the detection more resilient, currently the order of parameters matters. You don't want that for a production rule. \nSee blogpost (https://medium.com/falconforce/falconfriday-av-manipulation-0xff0e-67ed4387f9ab?source=friends_link&sk=3c7c499797bbb4d74879e102ef3ecf8f) \nfor more resilience considerations. The current approach can easily be bypassed by not using the powershell.exe executable. \nConsider adding more ways to detect this behavior.",
        "displayName": "Disable or Modify Windows Defender",
        "enabled": false,
        "query": "let defendertampering=dynamic([\"Set-MpPreference -DisableRealtimeMonitoring $true\",\"sc stop WinDefend\",\"sc delete WinDefend\",\"Set-MpPreference -DisableBehaviorMonitoring $true\",\"Set-MpPreference -ExclusionProcess\", \"Set-MpPreference -ExclusionExtension dll\",\"net stop security center\"]);\nDeviceProcessEvents\n| where ProcessCommandLine has_any (defendertampering)\n// If you have a lot of false positives coming from JetBrains, you can use the line below. \n//| where InitiatingProcessFolderPath !startswith @\"c:\\program files\\jetbrains\\\" and InitiatingProcessVersionInfoProductName !~ (\"Android Studio\")\n",
        "queryFrequency": "PT1H",
        "queryPeriod": "PT1H",
        "severity": "Medium",
        "suppressionDuration": "PT1H",
        "suppressionEnabled": false,
        "triggerOperator": "GreaterThan",
        "triggerThreshold": 0,
        "tactics": [
          "DefenseEvasion"
        ]
      }
    },
    {
      "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
      "name": "[concat(parameters('workspace'),'/Microsoft.SecurityInsights/',parameters('analytic9-id'))]",
      "apiVersion": "2020-01-01",
      "kind": "Scheduled",
      "location": "[parameters('workspace-location')]",
      "properties": {
        "description": "This query detects .NET being loaded from wscript or cscript to run .NET code, such as cactustorch and sharpshooter.\nAll based on the DotNetToJScript by James Foreshaw documented here https://github.com/tyranid/DotNetToJScript.",
        "displayName": "Detect .NET runtime being loaded in JScript for code execution",
        "enabled": false,
        "query": "DeviceImageLoadEvents \n| where FileName in~ (\"mscoree.dll\", \"mscorlib.dll\", \"mscorlib.ni.dll\") \n| where tolower(InitiatingProcessFileName) in (\"wscript.exe\", \"cscript.exe\", \"mshta.exe\")\n",
        "queryFrequency": "PT1H",
        "queryPeriod": "PT1H",
        "severity": "Medium",
        "suppressionDuration": "PT1H",
        "suppressionEnabled": false,
        "triggerOperator": "GreaterThan",
        "triggerThreshold": 0,
        "tactics": [
          "Execution"
        ]
      }
    },
    {
      "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
      "name": "[concat(parameters('workspace'),'/Microsoft.SecurityInsights/',parameters('analytic10-id'))]",
      "apiVersion": "2020-01-01",
      "kind": "Scheduled",
      "location": "[parameters('workspace-location')]",
      "properties": {
        "description": "This query searches for logins with an expired access credential (for example an expired cookie). It then matches the IP address from which the expired credential access occurred with the IP addresses of successful logins.\nIf there are logins with expired credentials, but no successful logins from an IP, this might indicate an attacker has copied the authentication cookie and is re-using it on another machine.",
        "displayName": "Expired access credentials being used in Azure",
        "enabled": false,
        "query": "// Timeframe to search for failed logins.\nlet timeframe=1d;\n// Timeframe to look back for successful logins from the same user by IP.\nlet lookback=7d;\nlet SuspiciousSignings=(\n    SigninLogs\n    | where TimeGenerated >= ago(timeframe)\n    | where ResourceDisplayName contains \"Windows Azure Active Directory\"\n    // 50132 = SsoArtifactInvalidOrExpired - The session is not valid due to password expiration or recent password change.\n    // 50173 = FreshTokenNeeded - The provided grant has expired due to it being revoked, and a fresh auth token is needed. \n    // 70008 = ExpiredOrRevokedGrant - The refresh token has expired due to inactivity. The token was issued on XXX and was inactive for a certain period of time.\n    // 81010 = DesktopSsoAuthTokenInvalid - Seamless SSO failed because the user's Kerberos ticket has expired or is invalid.\n    | where ResultType in (50173, 50132, 70008, 81010)\n    | summarize FailedCountPerDay=count(),FailedUserAgents=make_set(UserAgent), FailedCountries=make_set(LocationDetails.countryOrRegion),FailedIps=make_set(IPAddress) by UserPrincipalName, Day=bin(TimeGenerated, 1d)\n    | where FailedCountPerDay >= 1\n);\nlet SuccessLogins=(\n    SigninLogs\n    | where TimeGenerated >= ago(lookback)\n    | where UserPrincipalName in ((SuspiciousSignings | project UserPrincipalName))\n    | where ResultType == 0\n    | summarize count() by UserPrincipalName, IPAddress\n);\nSuspiciousSignings\n| mv-expand FailedIp=FailedIps\n| extend FailedIp=tostring(FailedIp)\n| join kind=leftanti SuccessLogins on $left.FailedIp==$right.IPAddress, UserPrincipalName\n",
        "queryFrequency": "P1D",
        "queryPeriod": "P7D",
        "severity": "Medium",
        "suppressionDuration": "PT1H",
        "suppressionEnabled": false,
        "triggerOperator": "GreaterThan",
        "triggerThreshold": 0,
        "tactics": [
          "CredentialAccess"
        ]
      }
    },
    {
      "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
      "name": "[concat(parameters('workspace'),'/Microsoft.SecurityInsights/',parameters('analytic11-id'))]",
      "apiVersion": "2020-01-01",
      "kind": "Scheduled",
      "location": "[parameters('workspace-location')]",
      "properties": {
        "description": "Attackers often match or approximate the name or location of legitimate files to avoid detection rules that are based trust of certain operating system processes.\nThis query detects mismatches in the parent-child relationship of core operating system processes to uncover different masquerading attempts.",
        "displayName": "Match Legitimate Name or Location - 2",
        "enabled": false,
        "query": "let ProcessRelations=datatable(ImageFile:string,ExpectedParent:dynamic) [\n  \"smss.exe\", dynamic([\"smss.exe\", \"ntoskrnl.exe\", \"\"]),\n  \"crmss.exe\", dynamic([\"smss.exe\"]),\n  \"wininit.exe\", dynamic([\"smss.exe\"]),\n  \"winlogon.exe\", dynamic([\"smss.exe\"]),\n  \"services.exe\", dynamic([\"wininit.exe\"]),\n  \"lsaiso.exe\", dynamic([\"wininit.exe\"]),\n  \"lsass.exe\", dynamic([\"wininit.exe\"]),\n  \"spoolsv.exe\", dynamic([\"services.exe\"]),\n  \"dllhost.exe\", dynamic([\"svchost.exe\", \"services.exe\"]),\n  \"lsm.exe\", dynamic([\"wininit.exe\"]),\n  \"svchost.exe\", dynamic([\"services.exe\", \"msmpeng.exe\"]),\n  \"runtimebroker.exe\", dynamic([\"svchost.exe\"]),\n  \"taskhostw.exe\", dynamic([\"svchost.exe\"]),\n  \"userinit.exe\", dynamic([\"winlogon.exe\"])\n  // Explorer can have a lot of parents in some environments\n  //,\"explorer.exe\", dynamic([\"userinit.exe\"])\n];\nDeviceProcessEvents\n| extend ImageFile = tostring(tolower(parse_path(tostring(FolderPath)).Filename))\n| extend ParentFile = tostring(tolower(parse_path(tostring(InitiatingProcessFolderPath)).Filename))\n| lookup kind=inner ProcessRelations on ImageFile\n| where not(set_has_element(ExpectedParent,ParentFile))\n",
        "queryFrequency": "PT1H",
        "queryPeriod": "PT1H",
        "severity": "Medium",
        "suppressionDuration": "PT1H",
        "suppressionEnabled": false,
        "triggerOperator": "GreaterThan",
        "triggerThreshold": 0,
        "tactics": [
          "DefenseEvasion"
        ]
      }
    },
    {
      "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
      "name": "[concat(parameters('workspace'),'/Microsoft.SecurityInsights/',parameters('analytic12-id'))]",
      "apiVersion": "2020-01-01",
      "kind": "Scheduled",
      "location": "[parameters('workspace-location')]",
      "properties": {
        "description": "The attacker sends a spearphishing email to a user. The email contains a link which points to a website that eventually \npresents the user a download of an MS Office document. This document contains a malicious macro. The macro triggers one of the ASR rules. \nThis detection looks for Office ASR violations triggered by an Office document opened from a browser.\nNote: be aware that you need to have the proper ASR rules enabled for this detection to work.",
        "displayName": "Office ASR rule triggered from browser spawned office process.",
        "enabled": false,
        "query": "// Add your own browsers here as well. \nlet browsers = dynamic([\"iexplore.exe\", \"chrome.exe\", \"firefox.exe\", \"msedge.exe\"]);\nDeviceEvents\n| where ActionType contains \"Office\"\n| where InitiatingProcessFileName in~ (browsers) or InitiatingProcessParentFileName in~ (browsers)\n// Ignore docx, xlsx and pptx files. These don't contain macros.\n| where not(FileName endswith \".docx\" or FileName endswith \".xlsx\" or FileName endswith \".pptx\")\n",
        "queryFrequency": "PT5M",
        "queryPeriod": "PT5M",
        "severity": "Medium",
        "suppressionDuration": "PT1H",
        "suppressionEnabled": false,
        "triggerOperator": "GreaterThan",
        "triggerThreshold": 0,
        "tactics": [
          "InitialAccess"
        ]
      }
    },
    {
      "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
      "name": "[concat(parameters('workspace'),'/Microsoft.SecurityInsights/',parameters('analytic13-id'))]",
      "apiVersion": "2020-01-01",
      "kind": "Scheduled",
      "location": "[parameters('workspace-location')]",
      "properties": {
        "description": "This query detects process injections using CreateRemoteThread, QueueUserAPC or SetThread context APIs, originating from an Office process (only Word/Excel/PowerPoint)\nthat might contains macros. Performing process injection from a macro is a common technique by attackers to escape out of the Office process into something\nlonger running.",
        "displayName": "Suspicious Process Injection from Office application",
        "enabled": false,
        "query": "DeviceEvents \n| where ActionType in (\"CreateRemoteThreadApiCall\", \"QueueUserApcRemoteApiCall\", \"SetThreadContextRemoteApiCall\")\n| where InitiatingProcessFileName in~ (\"winword.exe\", \"excel.exe\", \"powerpnt.exe\")\n| where InitiatingProcessCommandLine !contains \"/dde\"\n| where not(InitiatingProcessCommandLine has_any (\".docx\", \"dotx\",\".xlsx\", \".xltx\", \".pptx\")) // These files can't contain macros.\n// Enable the line below if the results are too noisy.\n//| where InitiatingProcessCommandLine has_any (\".doc\", \".wbk\", \".docm\", \".dot\", \".dotm\" \".xls\", \".xlsm\", \".xltm\", \".xla\",\".xll\", \".xlam\", \".ppt\", \".pptm\", \".pot\", \".potm\", \".ppsm\", \".sldm\") \n",
        "queryFrequency": "PT1H",
        "queryPeriod": "PT1H",
        "severity": "Medium",
        "suppressionDuration": "PT1H",
        "suppressionEnabled": false,
        "triggerOperator": "GreaterThan",
        "triggerThreshold": 0,
        "tactics": [
          "Execution"
        ]
      }
    },
    {
      "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
      "name": "[concat(parameters('workspace'),'/Microsoft.SecurityInsights/',parameters('analytic14-id'))]",
      "apiVersion": "2020-01-01",
      "kind": "Scheduled",
      "location": "[parameters('workspace-location')]",
      "properties": {
        "description": "This query detects a password spraying attack, where a single machine has performed a large number of failed login attempts, with a large number of different accounts. \nFor each account, the attacker uses just a few attempts to prevent account lockout. This query uses the DeviceLogonEvents per machine to detect a password spraying attacks. \nThe machine against which the password spraying is performed (can be DC, a server or even an endpoint) needs to be enrolled in Microsoft Defender for Endpoint.",
        "displayName": "Password Spraying",
        "enabled": false,
        "query": "let thresholdForUniqueFailedAccounts = 20;\nlet upperBoundOfFailedLogonsPerAccount = 10;\nlet ratioSuccessFailedLogons = 0.5;\nlet timeframe = 1d;\nDeviceLogonEvents\n| where Timestamp >= ago(timeframe)\n| where LogonType != \"Unlock\" and ActionType in (\"LogonSuccess\", \"LogonFailed\")\n| where not(isempty( RemoteIP) and isempty( RemoteDeviceName))\n| extend LocalLogon=parse_json(AdditionalFields)\n| where RemoteIPType != \"Loopback\"\n| summarize SuccessLogonCount = countif(ActionType == \"LogonSuccess\"), FailedLogonCount = countif(ActionType == \"LogonFailed\"),\n    UniqueAccountFailedLogons=dcountif(AccountName, ActionType == \"LogonFailed\"), FirstFailed=minif(Timestamp, ActionType == \"LogonFailed\"),\n    LastFailed=maxif(Timestamp, ActionType == \"LogonFailed\"), LastTimestamp=arg_max(Timestamp, tostring(ReportId)) by RemoteIP, DeviceName // RemoteIP is the source of the logon attempt.\n| project-rename IPAddress=RemoteIP\n| where UniqueAccountFailedLogons > thresholdForUniqueFailedAccounts and SuccessLogonCount*ratioSuccessFailedLogons < FailedLogonCount and UniqueAccountFailedLogons*upperBoundOfFailedLogonsPerAccount > FailedLogonCount \n",
        "queryFrequency": "P1D",
        "queryPeriod": "P1D",
        "severity": "Medium",
        "suppressionDuration": "PT1H",
        "suppressionEnabled": false,
        "triggerOperator": "GreaterThan",
        "triggerThreshold": 0,
        "tactics": [
          "CredentialAccess"
        ]
      }
    },
    {
      "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
      "name": "[concat(parameters('workspace'),'/Microsoft.SecurityInsights/',parameters('analytic15-id'))]",
      "apiVersion": "2020-01-01",
      "kind": "Scheduled",
      "location": "[parameters('workspace-location')]",
      "properties": {
        "description": "This query searches web proxy logs for a specific type of beaconing behavior by joining a number of sources together: \n- Traffic by actual web browsers - by looking at traffic generated by a UserAgent that looks like a browser and is used by multiple users\nto visit a large number of domains.\n- Users that make requests using one of these actual browsers, but only to a small set of domains, none of which are common domains.\n- The traffic is beacon-like; meaning that it occurs during many different hours of the day (i.e. periodic).",
        "displayName": "Beacon Traffic Based on Common User Agents Visiting Limited Number of Domains",
        "enabled": false,
        "query": "let timeframe = 1d; // Timeframe during which to search for beaconing behavior.\nlet lookback = 7d; // Look back period to find if browser was used for other domains by user.\nlet min_requests=50; // Minimum number of requests to consider it beacon traffic.\nlet min_hours=8; // Minimum number of different hours during which connections were made to consider it beacon traffic.\nlet trusted_user_count=10; // If visited by this many users a domain is considered 'trusted'.\nlet max_sites=3; // Maximum number of different sites visited using this user-agent.\n// Client-specific query to obtain 'browser-like' traffic from proxy logs.\nlet BrowserTraffic = (p:timespan) {\nCommonSecurityLog\n| where DeviceVendor == \"Zscaler\" and DeviceProduct == \"NSSWeblog\"\n| where TimeGenerated >ago(p)\n| project TimeGenerated, SourceUserName, DestinationHostName, RequestClientApplication\n| where (RequestClientApplication startswith \"Mozilla/\" and RequestClientApplication contains \"Gecko\")\n};\nlet CommonDomains = BrowserTraffic(timeframe)\n| summarize source_count=dcount(SourceUserName) by DestinationHostName\n| where source_count>trusted_user_count\n| project DestinationHostName;\nlet CommonUA = BrowserTraffic(timeframe)\n| summarize source_count=dcount(SourceUserName), host_count=dcount(DestinationHostName) by RequestClientApplication\n| where source_count>trusted_user_count and host_count > 100 // Normal browsers are browsers used by many people and visiting many different sites.\n| project RequestClientApplication;\n// Find browsers that are common, i.e. many users use them and they use them to visit many different sites,\n// but some users only use the browser to visit a very limited set of sites.\n// These are considered suspicious, since they might be an attacker masquerading a beacon as a legitimate browser.\nlet SuspiciousBrowers = BrowserTraffic(timeframe)\n| where RequestClientApplication in(CommonUA)\n| summarize BrowserHosts=make_set(DestinationHostName),request_count=count() by RequestClientApplication, SourceUserName\n| where array_length(BrowserHosts) <= max_sites and request_count >= min_requests\n| project RequestClientApplication, SourceUserName,BrowserHosts;\n// Just reporting on suspicious browsers gives too many false positives.\n// For example, users that have the browser open on the login screen of 1 specific application.\n// In the suspicious browsers we can search for 'beacon-like' behavior.\n// Get all browser traffic by the suspicious browsers.\nlet PotentialAlerts=SuspiciousBrowers\n| join BrowserTraffic(timeframe) on RequestClientApplication, SourceUserName\n// Find beaconing-like traffic - i.e. contacting the same host in many different hours.\n| summarize hour_count=dcount(bin(TimeGenerated,1h)), BrowserHosts=any(BrowserHosts), request_count=count() by RequestClientApplication, SourceUserName, DestinationHostName\n| where hour_count >= min_hours and request_count >= min_requests\n// Remove common domains like login.microsoft.com.\n| join kind=leftanti CommonDomains on DestinationHostName\n| summarize RareHosts=make_set(DestinationHostName), TotalRequestCount=sum(request_count), BrowserHosts=any(BrowserHosts) by RequestClientApplication, SourceUserName\n// Remove browsers that visit any common domains.\n| where array_length(RareHosts) == array_length(BrowserHosts);\n// Look back for X days to see if the browser was not used to visit more hosts.\n// This is to get rid of someone that started up the browser a long time ago, and left only a single tab open.\nPotentialAlerts\n| join BrowserTraffic(lookback) on SourceUserName, RequestClientApplication\n| summarize RareHosts=any(RareHosts),BrowserHosts1d=any(BrowserHosts),BrowserHostsLookback=make_set(DestinationHostName) by SourceUserName, RequestClientApplication\n| where array_length(RareHosts) == array_length(BrowserHostsLookback)\n",
        "queryFrequency": "P1D",
        "queryPeriod": "P7D",
        "severity": "Medium",
        "suppressionDuration": "PT1H",
        "suppressionEnabled": false,
        "triggerOperator": "GreaterThan",
        "triggerThreshold": 0,
        "tactics": [
          "CommandAndControl"
        ]
      }
    },
    {
      "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
      "name": "[concat(parameters('workspace'),'/Microsoft.SecurityInsights/',parameters('analytic16-id'))]",
      "apiVersion": "2020-01-01",
      "kind": "Scheduled",
      "location": "[parameters('workspace-location')]",
      "properties": {
        "description": "This detection monitors for the behavior that SharpRDP exhibits on the target system. The most relevant is leveraging taskmgr.exe to gain elevated execution, which means that taskmgr.exe is creating unexpected child processes.",
        "displayName": "Remote Desktop Protocol - SharpRDP",
        "enabled": false,
        "query": "let executions = DeviceProcessEvents\n| where InitiatingProcessFileName contains \"taskmgr\" and AccountName !contains \"_ladm\" // Include your LAPS /RID500 admin naming convention here. \n// Add the below filter to look for stock SharpRDP behavior. However, with minorchanges to the stock version of SharpRDP the filter below can be bypassed.\n//| where not(InitiatingProcessCommandLine has_any (\"/1\",\"/2\",\"/3\",\"/4\"))\n| where not(FolderPath =~ @\"c:\\Windows\\system32\\WerFault.exe\" and ProcessCommandLine contains \"-u -p\")\n| where not(FolderPath =~ @\"c:\\windows\\system32\\mmc.exe\" and ProcessCommandLine contains @\"C:\\WINDOWS\\System32\\services.msc\")\n| where not(FolderPath =~ @\"c:\\windows\\system32\\resmon.exe\");\nexecutions\n| join kind=leftsemi  (DeviceLogonEvents\n| where LogonType in ('Unlock', 'RemoteInteractive') and not (LogonType == 'Unlock' and RemoteIP == '127.0.0.1') and RemoteIP != \"\" and ActionType == \"LogonSuccess\") on DeviceId, LogonId\n",
        "queryFrequency": "PT1H",
        "queryPeriod": "PT1H",
        "severity": "Medium",
        "suppressionDuration": "PT1H",
        "suppressionEnabled": false,
        "triggerOperator": "GreaterThan",
        "triggerThreshold": 0,
        "tactics": [
          "LateralMovement"
        ]
      }
    },
    {
      "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
      "name": "[concat(parameters('workspace'),'/Microsoft.SecurityInsights/',parameters('analytic17-id'))]",
      "apiVersion": "2020-01-01",
      "kind": "Scheduled",
      "location": "[parameters('workspace-location')]",
      "properties": {
        "description": "Attackers often use LOLBINs that are renamed to avoid detection rules that are based on filenames.\nThis rule detects renamed LOLBINs by first searching for all the known SHA1 hashes of the LOLBINs in your DeviceProcessEvents. This list is then used as reference to find other files executed which have a name that doesn't match the original filename. \nThis query is really heavy on resources. Use it with care.",
        "displayName": "Rename System Utilities",
        "enabled": false,
        "query": "// Removed update.exe as LOLBIN. It's a way too generic name and causes a lot of noise. \nlet lolbin = dynamic([\"At.exe\", \"Atbroker.exe\", \"Bash.exe\", \"Bitsadmin.exe\", \"CertReq.exe\", \"Certutil.exe\", \"Cmd.exe\", \"Cmdkey.exe\", \"Cmstp.exe\", \"Control.exe\", \"Csc.exe\", \"Cscript.exe\", \"Desktopimgdownldr.exe\", \"Dfsvc.exe\", \"Diantz.exe\", \"Diskshadow.exe\", \"Dnscmd.exe\", \"Esentutl.exe\", \"Eventvwr.exe\", \"Expand.exe\", \"Extexport.exe\", \"Extrac32.exe\", \"Findstr.exe\", \"Forfiles.exe\", \"Ftp.exe\", \"GfxDownloadWrapper.exe\", \"Gpscript.exe\", \"Hh.exe\", \"Ie4uinit.exe\", \"Ieexec.exe\", \"Ilasm.exe\", \"Infdefaultinstall.exe\", \"Installutil.exe\", \"Jsc.exe\", \"Makecab.exe\", \"Mavinject.exe\", \"Microsoft.Workflow.Compiler.exe\", \"Mmc.exe\", \"MpCmdRun.exe\", \"Msbuild.exe\", \"Msconfig.exe\", \"Msdt.exe\", \"Mshta.exe\", \"Msiexec.exe\", \"Netsh.exe\", \"Odbcconf.exe\", \"Pcalua.exe\", \"Pcwrun.exe\", \"Pktmon.exe\", \"Presentationhost.exe\", \"Print.exe\", \"Psr.exe\", \"Rasautou.exe\", \"Reg.exe\", \"Regasm.exe\", \"Regedit.exe\", \"Regini.exe\", \"Register-cimprovider.exe\", \"Regsvcs.exe\", \"Regsvr32.exe\", \"Replace.exe\", \"Rpcping.exe\", \"Rundll32.exe\", \"Runonce.exe\", \"Runscripthelper.exe\", \"Sc.exe\", \"Schtasks.exe\", \"Scriptrunner.exe\", \"SyncAppvPublishingServer.exe\", \"Ttdinject.exe\", \"Tttracer.exe\", \"vbc.exe\", \"Verclsid.exe\", \"Wab.exe\", \"Wmic.exe\", \"Wscript.exe\", \"Wsreset.exe\", \"Xwizard.exe\", \"AgentExecutor.exe\", \"Appvlp.exe\", \"Bginfo.exe\", \"Cdb.exe\", \"csi.exe\", \"Devtoolslauncher.exe\", \"dnx.exe\", \"Dotnet.exe\", \"Dxcap.exe\", \"Excel.exe\", \"Mftrace.exe\", \"Msdeploy.exe\", \"msxsl.exe\", \"ntdsutil.exe\", \"Powerpnt.exe\", \"rcsi.exe\", \"Sqldumper.exe\", \"Sqlps.exe\", \"SQLToolsPS.exe\", \"Squirrel.exe\", \"te.exe\", \"Tracker.exe\", \"vsjitdebugger.exe\", \"Winword.exe\", \"Wsl.exe\"]); \nlet allHashesLolbin = materialize(\nDeviceProcessEvents\n| where FileName in~ (lolbin) and not(isempty(SHA1))\n| extend OriginalFilename = tolower(FileName)\n| summarize by SHA1, OriginalFilename);\nallHashesLolbin\n| join kind=inner hint.strategy = broadcast DeviceProcessEvents on SHA1\n| where FileName !~ OriginalFilename\n| where not(OriginalFilename =~ \"bash.exe\" and FileName =~ \"sh.exe\")\n| extend message=strcat(\"Usage of \", OriginalFilename, \". Renamed as \", FileName)\n| project-reorder message\n",
        "queryFrequency": "P1D",
        "queryPeriod": "P1D",
        "severity": "Medium",
        "suppressionDuration": "PT1H",
        "suppressionEnabled": false,
        "triggerOperator": "GreaterThan",
        "triggerThreshold": 0,
        "tactics": [
          "DefenseEvasion"
        ]
      }
    },
    {
      "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
      "name": "[concat(parameters('workspace'),'/Microsoft.SecurityInsights/',parameters('analytic18-id'))]",
      "apiVersion": "2020-01-01",
      "kind": "Scheduled",
      "location": "[parameters('workspace-location')]",
      "properties": {
        "description": "This query is based on detecting incoming RPC/TCP on the SCM, followed by the start of a child process of services.exe. Remotely interacting with the SCM triggers the RPC/TCP traffic on services.exe, and the creation of the child processes is a result of starting the service. \nThe query might look intimidating given its size. That's why we've commented the query per logic block to walk you through the details.",
        "displayName": "SMB/Windows Admin Shares",
        "enabled": false,
        "query": "// This rule is fairly complex, hence this documentation.\n// The rule tries to detect network activity from services.exe followed by the start of a new childvprocess of services.exe (i.e. a service start).\n// The rule tries to filter false positives as much as possible. \n// Since the FileProfile info is currently super-unreliable (unsure why), we have to work around it.\n// \n// The following list of LOLBINs is used to include all results which have a high reputation, but are LOLBINs.\nlet lolbins = dynamic([\"At.exe\", \"Atbroker.exe\", \"Bash.exe\", \"Bitsadmin.exe\", \"CertReq.exe\", \"Certutil.exe\", \"Cmd.exe\", \"Cmdkey.exe\", \"Cmstp.exe\", \"Control.exe\", \"Csc.exe\", \"Cscript.exe\", \"Desktopimgdownldr.exe\", \"Dfsvc.exe\", \"Diantz.exe\", \"Diskshadow.exe\", \"Dnscmd.exe\", \"Esentutl.exe\", \"Eventvwr.exe\", \"Expand.exe\", \"Extexport.exe\", \"Extrac32.exe\", \"Findstr.exe\", \"Forfiles.exe\", \"Ftp.exe\", \"GfxDownloadWrapper.exe\", \"Gpscript.exe\", \"Hh.exe\", \"Ie4uinit.exe\", \"Ieexec.exe\", \"Ilasm.exe\", \"Infdefaultinstall.exe\", \"Installutil.exe\", \"Jsc.exe\", \"Makecab.exe\", \"Mavinject.exe\", \"Microsoft.Workflow.Compiler.exe\", \"Mmc.exe\", \"MpCmdRun.exe\", \"Msbuild.exe\", \"Msconfig.exe\", \"Msdt.exe\", \"Mshta.exe\", \"Msiexec.exe\", \"Netsh.exe\", \"Odbcconf.exe\", \"Pcalua.exe\", \"Pcwrun.exe\", \"Pktmon.exe\", \"Presentationhost.exe\", \"Print.exe\", \"Psr.exe\", \"Rasautou.exe\", \"Reg.exe\", \"Regasm.exe\", \"Regedit.exe\", \"Regini.exe\", \"Register-cimprovider.exe\", \"Regsvcs.exe\", \"Regsvr32.exe\", \"Replace.exe\", \"Rpcping.exe\", \"Rundll32.exe\", \"Runonce.exe\", \"Runscripthelper.exe\", \"Sc.exe\", \"Schtasks.exe\", \"Scriptrunner.exe\", \"SyncAppvPublishingServer.exe\", \"Ttdinject.exe\", \"Tttracer.exe\", \"vbc.exe\", \"Verclsid.exe\", \"Wab.exe\", \"Wmic.exe\", \"Wscript.exe\", \"Wsreset.exe\", \"Xwizard.exe\", \"AgentExecutor.exe\", \"Appvlp.exe\", \"Bginfo.exe\", \"Cdb.exe\", \"csi.exe\", \"Devtoolslauncher.exe\", \"dnx.exe\", \"Dotnet.exe\", \"Dxcap.exe\", \"Excel.exe\", \"Mftrace.exe\", \"Msdeploy.exe\", \"msxsl.exe\", \"ntdsutil.exe\", \"Powerpnt.exe\", \"rcsi.exe\", \"Sqldumper.exe\", \"Sqlps.exe\", \"SQLToolsPS.exe\", \"Squirrel.exe\", \"te.exe\", \"Tracker.exe\", \"Update.exe\", \"vsjitdebugger.exe\", \"Winword.exe\", \"Wsl.exe\"]);\n// First, we want to get all the network events triggered by services.exe.\nlet networkEvents = materialize(DeviceNetworkEvents\n| where InitiatingProcessFileName in~ (\"services.exe\")\n| where ActionType == \"InboundConnectionAccepted\"\n| project-rename TimestampNetworkAct=Timestamp);\n// Next, we want to get the list of child processes created by services.exe. \nlet allServices = materialize ((\nDeviceProcessEvents \n// This is for optimization purposes, as filtering is way faster than joins.\n| where DeviceId in ((networkEvents | project DeviceId))\n//svchost and sppsvc are created very often as child processes of services.exe\n| where InitiatingProcessFileName =~ \"services.exe\" \n| project TimestampChild=Timestamp, DeviceId, DeviceName, FileName, ProcessCommandLine, SHA1, \nInitiatingProcessFileName, InitiatingProcessCommandLine, InitiatingProcessSHA1, InitiatingProcessId, TimestampServicesExe=InitiatingProcessCreationTime));\n// Now we are going to join the process creations and network events \n// and filter out all the tables _after_ the join where the child process \n// of svchost is not created shortly after the network activity (between 0 and 10 seconds). \nlet serviceNetworkEvents = materialize(\n(networkEvents \n    | join kind=inner hint.strategy=shuffle allServices on DeviceId, InitiatingProcessId, InitiatingProcessFileName\n) \n| where datetime_diff(\"Second\", TimestampChild, TimestampNetworkAct) between (0 .. 10)\n// Only get the results where the network activity occured more than 1 minute after services.exe has started (i.e. system boot).\n| where datetime_diff(\"Second\", TimestampNetworkAct, TimestampServicesExe) > 60);\n// Next, we want to check the reputation of all procssess.\n// Since FileProfile is not properly working, we use the built-in DeviceFileCertificateInfo for the AntiJoin.\n// The goal is to create a list of SHA1 hashes of the spawned processess \n// which have a low prevelance and are not in de DeviceFileCertificateInfo.\nlet serviceNetworkEventsWithSHA1 = materialize(serviceNetworkEvents\n| summarize count() by SHA1\n| join kind=leftanti hint.strategy=broadcast DeviceFileCertificateInfo on SHA1\n| where count_ < 100);\n// Finally, we need to bring everything together.\n// We take our subset of the child processess created by services.exe (serviceNetworkEvents).\n// Everything which is on our deny-list of SHA1 processess OR are LOLBINs, are filtered out.\n// Additionally, we filter out msiexec, since that appears to come very often.\nserviceNetworkEvents\n| where SHA1 in ((serviceNetworkEventsWithSHA1 | project SHA1)) or FileName in~ (lolbins) \n| where ProcessCommandLine !~ \"msiexec.exe /V\" \n// This summarize is optional if you want to group similar stuff.\n//| summarize ActionType=make_set(ActionType), RemoteIPs=make_set(strcat(RemoteIP, \":\", RemotePort, \" (\", RemoteUrl, \")\")), LocalPort=make_set(LocalPort) by bin(TimestampNetworkAct, 1m), DeviceId, DeviceName, LocalIP, Protocol, AdditionalFields, bin(TimestampChild, 1m), FileName, ProcessCommandLine, SHA1, InitiatingProcessFileName, InitiatingProcessCommandLine1, bin(TimestampServicesExe, 1m) \n",
        "queryFrequency": "PT1H",
        "queryPeriod": "PT1H",
        "severity": "Medium",
        "suppressionDuration": "PT1H",
        "suppressionEnabled": false,
        "triggerOperator": "GreaterThan",
        "triggerThreshold": 0,
        "tactics": [
          "LateralMovement"
        ]
      }
    },
    {
      "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
      "name": "[concat(parameters('workspace'),'/Microsoft.SecurityInsights/',parameters('analytic19-id'))]",
      "apiVersion": "2020-01-01",
      "kind": "Scheduled",
      "location": "[parameters('workspace-location')]",
      "properties": {
        "description": "The attacker sends a spearphishing email to a user. The email contains a link, which points to a website that eventually \npresents the user a download of an MS Office document. This document contains a malicious macro. The macro spawns a new child process providing initial access. \nThis detection looks for suspicious parent-process chains starting with a browser which spawns an Office application which spawns something else.",
        "displayName": "Suspicious parentprocess relationship - Office child processes.",
        "enabled": false,
        "query": "let browsers = dynamic([\"iexplore.exe\", \"chrome.exe\", \"firefox.exe\", \"msedge.exe\"]); // Customize this list for your environment.\nlet officeApps = dynamic([\"winword.exe\", \"excel.exe\", \"powerpnt.exe\"]); // Consider adding other Office applications such as Publisher, Visio and Access. \n// This is an allow-list of the most common child processes. This is a quick and dirty solution. Consider allow-listing the full process path instead of file name.\n// Also, make this list as short as possible. Remove anything from this list if it doesn't occur in your organization. \nlet allowList = dynamic([\"MSOSYNC.exe\", \"splwow64.exe\", \"csc.exe\", \"outlook.exe\", \"AcroRd32.exe\", \"Acrobat.exe\", \"explorer.exe\", \"DW20.exe\", \n\"Microsoft.Mashup.Container.Loader.exe\", \"Microsoft.Mashup.Container.NetFX40.exe\", \"WerFault.exe\", \"CLVIEW.exe\"]); \nDeviceProcessEvents\n| where InitiatingProcessParentFileName in~ (browsers) and InitiatingProcessFileName in~ (officeApps) and \nFileName !in~ (officeApps) and FileName !in~ (browsers) and FileName !in~ (allowList)\n| project-rename ProcessStart_Timestamp = Timestamp\n",
        "queryFrequency": "PT1H",
        "queryPeriod": "PT1H",
        "severity": "Medium",
        "suppressionDuration": "PT1H",
        "suppressionEnabled": false,
        "triggerOperator": "GreaterThan",
        "triggerThreshold": 0,
        "tactics": [
          "InitialAccess"
        ]
      }
    },
    {
      "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
      "name": "[concat(parameters('workspace'),'/Microsoft.SecurityInsights/',parameters('analytic20-id'))]",
      "apiVersion": "2020-01-01",
      "kind": "Scheduled",
      "location": "[parameters('workspace-location')]",
      "properties": {
        "description": "This detection looks at process executions - in some cases with specific command line attributes to filter a lot of common noise.",
        "displayName": "Trusted Developer Utilities Proxy Execution",
        "enabled": false,
        "query": "let Timeframe = 1h;\nDeviceProcessEvents\n| where Timestamp > ago(Timeframe)\n| where (FileName has_any (\"msbuild.exe\", \"msxsl.exe\")\nor (FileName has_any (\"vbc.exe\",\"csc.exe\",\"jsc.exe\") and ProcessCommandLine has_any (\"/exe\",\"/dll\",\"/pe64\",\"-exe\",\"-dll\",\"-pe64\"))\nor (FileName == (\"ilsasm.exe\") and ProcessCommandLine has_any (\"out\",\"target\",\"t:\",\"reference\",\"r:\")))\n// Filter initations by Visual Studio since this is expected behavior.\n  and not(FolderPath startswith \"C:\\\\Program Files (x86)\\\\Microsoft Visual Studio\" \n  or InitiatingProcessFolderPath startswith \"C:\\\\Program Files (x86)\\\\Microsoft Visual Studio\" \n  and (InitiatingProcessFileName == \"devenv.exe\" or InitiatingProcessFileName == \"WDExpress.exe\"))\n",
        "queryFrequency": "PT1H",
        "queryPeriod": "PT1H",
        "severity": "Medium",
        "suppressionDuration": "PT1H",
        "suppressionEnabled": false,
        "triggerOperator": "GreaterThan",
        "triggerThreshold": 0,
        "tactics": [
          "DefenseEvasion"
        ]
      }
    },
    {
      "type": "Microsoft.OperationalInsights/workspaces/providers/metadata",
      "apiVersion": "2021-03-01-preview",
      "properties": {
        "version": "1.1.0",
        "kind": "Solution",
        "contentId": "[variables('_sourceId')]",
        "parentId": "[variables('_sourceId')]",
        "source": {
          "kind": "Solution",
          "name": "FalconFriday",
          "sourceId": "[variables('_sourceId')]"
        },
        "author": {
          "name": "Nikhil Tripathi",
          "email": "v-ntripathi@microsoft.com"
        },
        "support": {
          "name": "FalconForce",
          "tier": "Partner",
          "link": "https://www.falconforce.nl/en/"
        },
        "dependencies": {
          "operator": "AND",
          "criteria": [
            {
              "kind": "AnalyticsRule",
              "contentId": "[variables('_AzureADRareUserAgentAppSignin_AnalyticalRules')]",
              "version": "1.1.0"
            },
            {
              "kind": "AnalyticsRule",
              "contentId": "[variables('_AzureADUserAgentOSmissmatch_AnalyticalRules')]",
              "version": "1.1.0"
            },
            {
              "kind": "AnalyticsRule",
              "contentId": "[variables('_COMHijacking_AnalyticalRules')]",
              "version": "1.1.0"
            },
            {
              "kind": "AnalyticsRule",
              "contentId": "[variables('_CertutilIngressToolTransfer_AnalyticalRules')]",
              "version": "1.1.0"
            },
            {
              "kind": "AnalyticsRule",
              "contentId": "[variables('_CreateProcessWithToken_AnalyticalRules')]",
              "version": "1.1.0"
            },
            {
              "kind": "AnalyticsRule",
              "contentId": "[variables('_DCOMLateralMovement_AnalyticalRules')]",
              "version": "1.1.0"
            },
            {
              "kind": "AnalyticsRule",
              "contentId": "[variables('_DLLSideLoading_AnalyticalRules')]",
              "version": "1.1.0"
            },
            {
              "kind": "AnalyticsRule",
              "contentId": "[variables('_DisableOrModifyWindowsDefender_AnalyticalRules')]",
              "version": "1.1.0"
            },
            {
              "kind": "AnalyticsRule",
              "contentId": "[variables('_DotNetToJScript_AnalyticalRules')]",
              "version": "1.1.0"
            },
            {
              "kind": "AnalyticsRule",
              "contentId": "[variables('_ExpiredAccessCredentials_AnalyticalRules')]",
              "version": "1.1.0"
            },
            {
              "kind": "AnalyticsRule",
              "contentId": "[variables('_MatchLegitimateNameOrLocation_AnalyticalRules')]",
              "version": "1.1.0"
            },
            {
              "kind": "AnalyticsRule",
              "contentId": "[variables('_OfficeASRFromBrowser_AnalyticalRules')]",
              "version": "1.1.0"
            },
            {
              "kind": "AnalyticsRule",
              "contentId": "[variables('_OfficeProcessInjection_AnalyticalRules')]",
              "version": "1.1.0"
            },
            {
              "kind": "AnalyticsRule",
              "contentId": "[variables('_PasswordSprayingWithMDE_AnalyticalRules')]",
              "version": "1.1.0"
            },
            {
              "kind": "AnalyticsRule",
              "contentId": "[variables('_RecognizingBeaconingTraffic_AnalyticalRules')]",
              "version": "1.1.0"
            },
            {
              "kind": "AnalyticsRule",
              "contentId": "[variables('_RemoteDesktopProtocol_AnalyticalRules')]",
              "version": "1.1.0"
            },
            {
              "kind": "AnalyticsRule",
              "contentId": "[variables('_RenameSystemUtilities_AnalyticalRules')]",
              "version": "1.1.0"
            },
            {
              "kind": "AnalyticsRule",
              "contentId": "[variables('_SMBWindowsAdminShares_AnalyticalRules')]",
              "version": "1.1.0"
            },
            {
              "kind": "AnalyticsRule",
              "contentId": "[variables('_SuspiciousParentProcessRelationship_AnalyticalRules')]",
              "version": "1.1.0"
            },
            {
              "kind": "AnalyticsRule",
              "contentId": "[variables('_TrustedDeveloperUtilitiesProxyExecution_AnalyticalRules')]",
              "version": "1.1.0"
            }
          ]
        },
        "firstPublishDate": "2021-10-18",
        "providers": [
          "FalconForce"
        ],
        "categories": {
          "domains": [
            "User Behavior (UEBA)",
            "Security  Insider Threat"
          ]
        }
      },
      "name": "[concat(parameters('workspace'),'/Microsoft.SecurityInsights/', variables('_sourceId'))]"
    }
  ],
  "outputs": {}
}
