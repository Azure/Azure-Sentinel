using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Azure.Functions.Worker;
using Microsoft.Extensions.Logging;
using Sentinel.DTOs;
using Sentinel.Helpers;
using Sentinel.Managers;
using Veeam.AC.VBR.ApiClient.Api.v1_2_rev1.Models;

namespace Sentinel.Functions
{

    public class GetMalwareEvents
    {

        private readonly IVbrConnectionsManager _vbrConnectionsManager;
        private readonly ILogAnalyticsManager _logAnalyticsManager;
        private readonly ILogger<GetMalwareEvents> _logger;

        public GetMalwareEvents(IVbrConnectionsManager vbrConnectionsManager, ILogAnalyticsManager logAnalyticsManager, ILogger<GetMalwareEvents> logger)
        {
            _logAnalyticsManager = logAnalyticsManager;
            _vbrConnectionsManager = vbrConnectionsManager;

            _logger = logger;
        }


        [Function("GetAllMalwareEventsAsync")]
        public async Task<IActionResult> GetMalwareEventsAsync([HttpTrigger(AuthorizationLevel.Function, "get", "post")] HttpRequest request)
        {
            _logger.LogInformation($"Calling {nameof(GetMalwareEventsAsync)} Azure Function was triggered with query parameters {request.QueryString}");

            var vbrHostName = RequestParser.GetVbrHostNameFromQuery(request);

            var client = await _vbrConnectionsManager.GetOrCreateAsync(vbrHostName);

            return await FunctionErrorHandler.ExecuteAsync(
                _logger,
                nameof(GetMalwareEventsAsync),
                request.QueryString.ToString(),
                vbrHostName,

                async () =>
                {
                    var filter = new SuspiciousActivityEventsFilters();
                    var latestDataTime = await _logAnalyticsManager.GetLatestDateTimeIngested(vbrHostName, IngestedStreamType.MalwareEvents);

                    filter.DetectedAfterTimeUtcFilter = latestDataTime;

                    var malwareEvents = await client.GetAllMalwareEventsAsync(filter);

                    await _logAnalyticsManager.SaveMalwareEventsToCustomTableAsync(malwareEvents, vbrHostName);

                    return malwareEvents;
                },

                resp => Task.FromResult<IActionResult>(new OkObjectResult(resp))
            );
        }

        [Function("CreateMalwareEventAsync")]
        public async Task<IActionResult> CreateMalwareEventAsync([HttpTrigger(AuthorizationLevel.Function, "get", "post")] HttpRequest request)
        {
            var vbrHostName = RequestParser.GetVbrHostNameFromQuery(request);

            var detectionTime = RequestParser.GetDetectionTimeUtc(request);
            var details = RequestParser.GetDetails(request);
            var engine = RequestParser.GetEngine(request);

            var machineFqdn = RequestParser.GetMachineFqdn(request);
            var machineIpv6 = RequestParser.GetMachineIpv6(request);
            var machineIpv4 = RequestParser.GetMachineIpv4(request);
            var machineUuid = RequestParser.GetMachineUuid(request);

            var client = await _vbrConnectionsManager.GetOrCreateAsync(vbrHostName);

            return await FunctionErrorHandler.ExecuteAsync(
                _logger,
                nameof(CreateMalwareEventAsync),
                request.QueryString.ToString(),
                vbrHostName,

                async () =>
                {
                    var suspiciousActivityEventSpec = new SuspiciousActivityEventSpec()
                    {
                        Details = details,
                        DetectionTimeUtc = detectionTime,
                        Engine = engine,
                        Machine = new SuspiciousActivityMachineSpec()
                        {
                            Fqdn = machineFqdn,
                            Ipv6 = machineIpv6,
                            Uuid = machineUuid,
                            Ipv4 = machineIpv4
                        }
                    };

                    return await client.CreateSuspiciousActivityEventAsync(suspiciousActivityEventSpec);
                },

                resp => Task.FromResult<IActionResult>(new OkObjectResult(resp))
            );
        }
    }
}
