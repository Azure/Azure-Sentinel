# Each pull request that updates ASIM parsers triggers the script.
# The script runs ASIM Schema and Data testers on the "eco-connector-test" workspace.
name: Run ASIM tests on "ASIM-SchemaDataTester-GithubShared" workspace
on:
  pull_request_target:
    types: [opened, edited, reopened, synchronize, labeled]
    branches:
      - master
      - asim-github-workflow
    paths:
    - 'Parsers/ASimDns/Parsers/**'
    - 'Parsers/ASimNetworkSession/Parsers/**'
    - 'Parsers/ASimWebSession/Parsers/**'
    - 'Parsers/ASimProcessEvent/Parsers/**'
    - 'Parsers/ASimAuditEvent/Parsers/**'
    - 'Parsers/ASimAuthentication/Parsers/**'
    - 'Parsers/ASimFileEvent/Parsers/**'
    - 'Parsers/ASimRegistryEvent/Parsers/**'
    - 'Parsers/ASimUserManagement/Parsers/**'
    - 'Parsers/ASimDhcpEvent/Parsers/**'
    - 'Parsers/ASimAlertEvent/Parsers/**'
    
  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

concurrency:
  group: asim-tests-${{ github.event.pull_request.number || github.sha }}
  cancel-in-progress: true

jobs: 
  # Security gate: Fork PRs require manual approval via "safe to test" label
  # Internal PRs (same repo) can proceed without labels
  security-gate:
    name: Security approval gate for fork PRs
    runs-on: ubuntu-latest
    timeout-minutes: 5
    permissions:
      contents: read
      pull-requests: write
      issues: write
    outputs:
      approved: ${{ steps.check-approval.outputs.approved }}
    steps:
      - name: Check if PR needs approval
        id: check-approval
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Function to log with consistent formatting
          log_info() { echo "ℹ️  $1"; }
          log_success() { echo "✅ $1"; }
          log_warning() { echo "⚠️  $1"; }
          log_error() { echo "❌ $1"; }
          
          log_info "Starting PR approval check..."
          
          # Check if this is a fork PR
          is_fork="${{ github.event.pull_request.head.repo.fork }}"
          log_info "Fork PR: $is_fork"
          
          if [ "$is_fork" = "true" ]; then
            log_info "FORK PR DETECTED - Proceeding with security checks"
            
            # Check if "safe to test" label is present
            labels='${{ toJson(github.event.pull_request.labels.*.name) }}'
            log_info "Available labels: $labels"
            
            if echo "$labels" | grep -q "safe to test"; then
              log_success "'safe to test' label found - checking for race conditions"
              
              # Get PR details for race condition check
              pr_number="${{ github.event.pull_request.number }}"
              repo="${{ github.repository }}"
              
              # Fetch timeline with authentication and error handling
              log_info "Fetching timeline for PR #$pr_number..."
              if ! timeline_response=$(curl -s -f -H "Authorization: token $GITHUB_TOKEN" \
                -H "Accept: application/vnd.github.v3+json" \
                "https://api.github.com/repos/$repo/issues/$pr_number/timeline"); then
                log_error "Failed to fetch PR timeline from GitHub API"
                echo "approved=false" >> $GITHUB_OUTPUT
                echo "needs_reapproval=true" >> $GITHUB_OUTPUT
                exit 1
              fi
              
              # Get the most recent "safe to test" label timestamp
              label_created=$(echo "$timeline_response" \
                | jq -r '.[] | select(.event == "labeled" and .label.name == "safe to test") | .created_at' 2>/dev/null \
                | tail -1)
              
              if [ -n "$label_created" ] && [ "$label_created" != "null" ]; then
                # Get latest commit timestamp
                latest_commit_date="${{ github.event.pull_request.head.repo.pushed_at }}"
                
                log_info "Label timestamp: $label_created"
                log_info "Commit timestamp: $latest_commit_date"
                
                # Convert to epoch for comparison
                if ! label_epoch=$(date -d "$label_created" +%s 2>/dev/null); then
                  log_error "Failed to parse label timestamp: $label_created"
                  echo "approved=false" >> $GITHUB_OUTPUT
                  echo "needs_reapproval=true" >> $GITHUB_OUTPUT
                  exit 1
                fi
                
                if ! commit_epoch=$(date -d "$latest_commit_date" +%s 2>/dev/null); then
                  log_error "Failed to parse commit timestamp: $latest_commit_date"
                  echo "approved=false" >> $GITHUB_OUTPUT
                  echo "needs_reapproval=true" >> $GITHUB_OUTPUT
                  exit 1
                fi
                
                # Race condition check: commits after label
                if [ "$commit_epoch" -gt "$label_epoch" ]; then
                  log_warning "RACE CONDITION: Commits pushed after label approval"
                  log_warning "Re-approval required for security"
                  echo "approved=false" >> $GITHUB_OUTPUT
                  echo "needs_reapproval=true" >> $GITHUB_OUTPUT
                  exit 1
                else
                  log_success "Race condition check passed - safe to proceed"
                  echo "approved=true" >> $GITHUB_OUTPUT
                fi
              else
                log_error "Could not determine label timestamp"
                echo "approved=false" >> $GITHUB_OUTPUT
                echo "needs_reapproval=true" >> $GITHUB_OUTPUT
                exit 1
              fi
            else
              log_info "'safe to test' label not found - approval required"
              echo "approved=false" >> $GITHUB_OUTPUT
              echo "needs_approval=true" >> $GITHUB_OUTPUT
              exit 1
            fi
          else
            log_success "Internal PR - auto-approved"
            echo "approved=true" >> $GITHUB_OUTPUT
          fi
          
          # Display final result
          final_approved=$(grep "^approved=" $GITHUB_OUTPUT | cut -d'=' -f2)
          log_info "Final decision: approved=$final_approved"
      
      - name: Comment on fork PR for approval guidance
        if: |
          always() && 
          github.event.pull_request.head.repo.fork == true && 
          steps.check-approval.conclusion == 'failure' &&
          (steps.check-approval.outputs.needs_approval == 'true' || 
           steps.check-approval.outputs.needs_reapproval == 'true')
        uses: actions/github-script@d7906e4ad0b1822421a7e6a35d5ca353c962f410
        with:
          script: |
            // Helper function for consistent logging
            const log = (level, message) => {
              const icons = { info: 'ℹ️', success: '✅', warning: '⚠️', error: '❌' };
              console.log(`${icons[level] || 'ℹ️'} ${message}`);
            };
            
            log('info', 'Comment step triggered for fork PR approval guidance');
            log('info', `needs_approval: ${{ steps.check-approval.outputs.needs_approval }}`);
            log('info', `needs_reapproval: ${{ steps.check-approval.outputs.needs_reapproval }}`);
            
            try {
              // Fetch existing comments
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
              });
              
              // Look for existing security guidance comments (more robust detection)
              const botComments = comments.filter(comment => 
                comment.user.login === 'github-actions[bot]' &&
                (comment.body.includes('🔒 **Security Approval Required**') ||
                 comment.body.includes('🔒 **Security Re-approval Required**'))
              );
              
              // Determine approval type and create appropriate message
              const needsReapproval = '${{ steps.check-approval.outputs.needs_reapproval }}' === 'true';
              const timestamp = new Date().toISOString();
              
              let commentBody;
              if (needsReapproval) {
                log('info', 'Re-approval scenario detected');
                commentBody = `🔒 **Security Re-approval Required**
              
              ⚠️ **Race condition detected**: New commits were pushed after the \`safe to test\` label was added.
              
              **For security, a maintainer must:**
              1. 📝 Review the latest commits carefully for any security concerns
              2. 🏷️ Remove the \`safe to test\` label
              3. 🏷️ Re-add the \`safe to test\` label if the new commits are safe
              
              This ensures that all commits have been properly reviewed before testing with repository secrets.
              
              ---
              *🤖 Automated security check • Updated: ${timestamp}*  
              *Learn more: [GitHub Security Lab - Preventing PWN Requests](https://securitylab.github.com/resources/github-actions-preventing-pwn-requests/)*`;
              } else {
                log('info', 'Initial approval scenario detected');
                commentBody = `🔒 **Security Approval Required**
              
              This fork PR requires manual approval before automated testing can run.
              
              **For security, a maintainer must:**
              1. 📝 Review the code changes carefully
              2. 🏷️ Add the \`safe to test\` label if the changes are safe to execute
              
              This protects against malicious code execution in fork contributions.
              
              ---
              *🤖 Automated security check • Created: ${timestamp}*  
              *Learn more: [GitHub Security Lab - Preventing PWN Requests](https://securitylab.github.com/resources/github-actions-preventing-pwn-requests/)*`;
              }
              
              // Handle comment creation/update logic
              if (botComments.length > 0) {
                // Update the most recent bot comment
                const latestComment = botComments[botComments.length - 1];
                log('info', `Updating existing comment (ID: ${latestComment.id})`);
                
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: latestComment.id,
                  body: commentBody
                });
                
                // Clean up any additional bot comments to avoid spam
                if (botComments.length > 1) {
                  log('info', `Cleaning up ${botComments.length - 1} duplicate comments`);
                  for (let i = 0; i < botComments.length - 1; i++) {
                    await github.rest.issues.deleteComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      comment_id: botComments[i].id
                    });
                  }
                }
                
                log('success', 'Updated existing security guidance comment');
              } else {
                // Create new comment
                log('info', 'Creating new security guidance comment');
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: commentBody
                });
                log('success', 'Created new security guidance comment');
              }
              
              log('success', 'Comment operation completed successfully');
              
            } catch (error) {
              log('error', `Failed to post comment: ${error.message}`);
              if (error.response) {
                log('error', `API Response: ${error.response.status} - ${error.response.data?.message || 'Unknown error'}`);
              }
              // Don't fail the step if comment posting fails
              log('warning', 'Comment posting failed, but continuing workflow...');
            }

  Run-ASim-TemplateValidation:
    name: Run ASim Template Validation tests
    needs: security-gate
    if: needs.security-gate.outputs.approved == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout pull request branch
        uses: actions/checkout@v3
        with:
            ref: ${{github.event.pull_request.head.ref}}
            repository: ${{github.event.pull_request.head.repo.full_name}}
            persist-credentials: false # otherwise, the token used is the GITHUB_TOKEN, instead of your personal access token.
            fetch-depth: 0 # otherwise, there would be errors pushing refs to the destination repository.
      - name: Setup git config
        run: |
              git config --local user.name "github-actions[bot]"
              git config --local user.email "<>"
      - name: Merge master into pull request branch
        run: |
              git merge origin/master
              Conflicts=$(git ls-files -u | wc -l)
              if [ "$Conflicts" -gt 0 ] ; then
                echo "There is a merge conflict. Aborting"
                git merge --abort
                exit 1
              fi
      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: '3.x'
      - name: Install dependencies
        run: |
              python -m pip install --upgrade pip
              pip install requests
              pip install PyYAML
              pip install tabulate
      - name: Run ASim parsers template validations python script
        run: |
              filePath=".script/tests/asimParsersTest/VerifyASimParserTemplate.py"
              url="https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/.script/tests/asimParsersTest/VerifyASimParserTemplate.py" 
              # Check if file exists and delete if it does
              if [ -f "$filePath" ]; then
                rm -f "$filePath"
              fi
              # Download the file
              echo "Downloading script from the master: $url"
              curl -o "$filePath" "$url"
              # Execute the script
              python "$filePath" 
  Run-ASim-Sample-Data-Ingest:
    needs: Run-ASim-TemplateValidation
    name: Run ASim Sample Data Ingestion
    runs-on: ubuntu-latest
    steps:
      - name: Checkout pull request branch
        uses: actions/checkout@v4
        with:
            ref: ${{github.event.pull_request.head.ref}}
            repository: ${{github.event.pull_request.head.repo.full_name}}
            persist-credentials: false # otherwise, the token used is the GITHUB_TOKEN, instead of your personal access token.
            fetch-depth: 0 # otherwise, there would be errors pushing refs to the destination repository.
      - name: Setup git config
        run: |
              git config --local user.name "github-actions[bot]"
              git config --local user.email "<>"
      - name: Merge master into pull request branch
        run: |
              git merge origin/master
              Conflicts=$(git ls-files -u | wc -l)
              if [ "$Conflicts" -gt 0 ] ; then
                echo "There is a merge conflict. Aborting"
                git merge --abort
                exit 1
              fi
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'
      - name: Install dependencies
        run: |
              python -m pip install --upgrade pip
              pip install azure-identity
              pip install requests
              pip install PyYAML
              pip install azure-monitor-ingestion
              pip install azure-core
      - name: Login to Azure Public Cloud
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_ASIM_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          allow-no-subscriptions: true
      - name: Asim Sample Log Ingestion
        id: Ingestlogs
        run: |
              filePath=".script/tests/asimParsersTest/ingestASimSampleData.py"
              url="https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/.script/tests/asimParsersTest/ingestASimSampleData.py" 
              # Check if file exists and delete if it does
              if [ -f "$filePath" ]; then
                rm -f "$filePath"
              fi
              # Download the file
              echo "Downloading script from the master: $url"
              curl -o "$filePath" "$url"
              chmod +x "$filePath"
              # Execute the script
              python "$filePath" "${{ github.event.pull_request.number }}"
  Run-ASim-Schema-Data-tests:
    needs: Run-ASim-Sample-Data-Ingest
    name: Run ASim Schema and Data tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout pull request branch
        uses: actions/checkout@v3
        with:
          ref: ${{ github.event.pull_request.head.ref }}
          repository: ${{ github.event.pull_request.head.repo.full_name }}
          persist-credentials: false
          fetch-depth: 0 # otherwise, there would be errors pushing refs to the destination repository.
      
      - name: Login to Azure Public Cloud with AzPowershell
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_ASIM_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          enable-AzPSSession: true
          allow-no-subscriptions: true

      - name: Setup git config
        run: |
          git config --local user.name "github-actions[bot]"
          git config --local user.email "<>"

      - name: Merge master into pull request branch
        run: |
          git merge origin/master
          Conflicts=$(git ls-files -u | wc -l)
          if [ "$Conflicts" -gt 0 ] ; then
            echo "There is a merge conflict. Aborting"
            git merge --abort
            exit 1
          fi
      - name: Run ASIM Schema and Data tests PowerShell script
        uses: azure/powershell@v2
        with:
          inlineScript: |
            $filePath = ".script/tests/asimParsersTest/runAsimTesters.ps1"
            $url = "https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/.script/tests/asimParsersTest/runAsimTesters.ps1"
            # Check if file exists and delete if it does
            if (Test-Path $filePath) {
              Remove-Item $filePath -Force
            }
            # Download the runAsimTesters file
            Write-Host "Downloading script from the master: $url"
            Invoke-WebRequest -Uri $url -OutFile $filePath
            # download the convertYamlToObject.ps1 script form master
            $filePath_convert_yaml = ".script/tests/asimParsersTest/convertYamlToObject.ps1"
            $url_convert_yaml = "https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/.script/tests/asimParsersTest/convertYamlToObject.ps1"
            # Check if file exists and delete if it does
            if (Test-Path $filePath_convert_yaml) {
              Remove-Item $filePath_convert_yaml -Force
            }
            # Download the convertYamlToObject file
            Write-Host "Downloading script from the master: $url_convert_yaml"
            Invoke-WebRequest -Uri $url_convert_yaml -OutFile $filePath_convert_yaml 
            # Execute the script
            & $filePath
          azPSVersion: "latest"
  Run-ASim-Parser-Filtering-Tests:
    needs: Run-ASim-Sample-Data-Ingest
    name: Run ASim Parser Filtering tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout pull request branch
        uses: actions/checkout@v3
        with:
          ref: ${{ github.event.pull_request.head.ref }}
          repository: ${{ github.event.pull_request.head.repo.full_name }}
          persist-credentials: false # otherwise, the token used is the GITHUB_TOKEN, instead of your personal access token.
          fetch-depth: 0 # otherwise, there would be errors pushing refs to the destination repository.
      - name: Setup git config
        run: |
              git config --local user.name "github-actions[bot]"
              git config --local user.email "<>"
      - name: Merge master into pull request branch
        run: |
          git merge origin/master
          Conflicts=$(git ls-files -u | wc -l)
          if [ "$Conflicts" -gt 0 ] ; then
            echo "There is a merge conflict. Aborting"
            git merge --abort
            exit 1
          fi
      - name: Setup Python
        uses: actions/setup-python@v2
        with:
          python-version: '3.x'
      - name: Install dependencies
        run: |
              python -m pip install --upgrade pip
              pip install PyYAML
              pip install azure-identity
              pip install azure-monitor-query
      - name: Login to Azure Public Cloud
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_ASIM_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          allow-no-subscriptions: true
      - name: Run ASim parsers filtering tests python script
        run: |
          filePath=".script/tests/asimParsersTest/ASimFilteringTest.py"
          url="https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/.script/tests/asimParsersTest/ASimFilteringTest.py"
          # Check if file exists and delete if it does
          if [ -f "$filePath" ]; then
            rm -f "$filePath"
          fi
          # Download the file
          echo "Downloading script from the master: $url"
          curl -o "$filePath" "$url"
          # Execute the script
          python "$filePath"